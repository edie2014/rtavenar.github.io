<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../../../css/md.css" type="text/css" />
  <script src="https://d3eoax9i5htok0.cloudfront.net/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.1/anchor.min.js"></script>
</head>
<body onload="anchors.options = {visible: 'always'}; anchors.add();">
<div id="TOC">
<h2>Table des mati&#232;res</h2>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#structures-de-donn&#233;es-et-structures-de-contr&#244;le"><span class="toc-section-number">2</span> Structures de donn&#233;es et structures de contr&#244;le</a><ul>
<li><a href="#variables"><span class="toc-section-number">2.1</span> Variables</a><ul>
<li><a href="#types-des-variables-python"><span class="toc-section-number">2.1.1</span> Types des variables Python</a></li>
<li><a href="#op&#233;ration-dassignation"><span class="toc-section-number">2.1.2</span> Op&#233;ration d&#8217;assignation</a></li>
<li><a href="#op&#233;rateurs-et-priorit&#233;"><span class="toc-section-number">2.1.3</span> Op&#233;rateurs et priorit&#233;</a></li>
</ul></li>
<li><a href="#structures-de-contr&#244;le"><span class="toc-section-number">2.2</span> Structures de contr&#244;le</a><ul>
<li><a href="#structures-conditionnelles"><span class="toc-section-number">2.2.1</span> Structures conditionnelles</a></li>
<li><a href="#boucles"><span class="toc-section-number">2.2.2</span> Boucles</a><ul>
<li><a href="#boucles-while"><span class="toc-section-number">2.2.2.1</span> Boucles <code>while</code></a></li>
<li><a href="#boucles-for"><span class="toc-section-number">2.2.2.2</span> Boucles <code>for</code></a></li>
</ul></li>
<li><a href="#fonctions"><span class="toc-section-number">2.2.3</span> Fonctions</a><ul>
<li><a href="#d&#233;finition-dune-fonction"><span class="toc-section-number">2.2.3.1</span> D&#233;finition d&#8217;une fonction</a></li>
<li><a href="#arguments-optionnels-dune-fonction"><span class="toc-section-number">2.2.3.2</span> Argument(s) optionnel(s) d&#8217;une fonction</a></li>
</ul></li>
</ul></li>
<li><a href="#les-modules-en-python"><span class="toc-section-number">2.3</span> Les modules en Python</a></li>
</ul></li>
<li><a href="#les-listes"><span class="toc-section-number">3</span> Les listes</a><ul>
<li><a href="#avant-propos-listes-et-it&#233;rables"><span class="toc-section-number">3.1</span> Avant-propos : listes et it&#233;rables</a></li>
<li><a href="#cr&#233;ation-de-liste"><span class="toc-section-number">3.2</span> Cr&#233;ation de liste</a></li>
<li><a href="#acc&#232;s-aux-&#233;l&#233;ments-dune-liste"><span class="toc-section-number">3.3</span> Acc&#232;s aux &#233;l&#233;ments d&#8217;une liste</a></li>
<li><a href="#parcours-dune-liste"><span class="toc-section-number">3.4</span> Parcours d&#8217;une liste</a><ul>
<li><a href="#parcours-des-&#233;l&#233;ments"><span class="toc-section-number">3.4.1</span> Parcours des &#233;l&#233;ments</a></li>
<li><a href="#parcours-par-indices"><span class="toc-section-number">3.4.2</span> Parcours par indices</a></li>
<li><a href="#parcours-par-&#233;l&#233;ments-et-indices"><span class="toc-section-number">3.4.3</span> Parcours par &#233;l&#233;ments et indices</a></li>
</ul></li>
<li><a href="#manipulations-de-listes"><span class="toc-section-number">3.5</span> Manipulations de listes</a><ul>
<li><a href="#insertion-d&#233;l&#233;ment"><span class="toc-section-number">3.5.1</span> Insertion d&#8217;&#233;l&#233;ment</a></li>
<li><a href="#suppression-d&#233;l&#233;ment"><span class="toc-section-number">3.5.2</span> Suppression d&#8217;&#233;l&#233;ment</a></li>
<li><a href="#recherche-d&#233;l&#233;ment"><span class="toc-section-number">3.5.3</span> Recherche d&#8217;&#233;l&#233;ment</a></li>
<li><a href="#cr&#233;ation-de-listes-composites"><span class="toc-section-number">3.5.4</span> Cr&#233;ation de listes composites</a></li>
<li><a href="#tri-de-liste"><span class="toc-section-number">3.5.5</span> Tri de liste</a></li>
</ul></li>
<li><a href="#copie-de-liste"><span class="toc-section-number">3.6</span> Copie de liste</a></li>
<li><a href="#bonus-listes-en-compr&#233;hension"><span class="toc-section-number">3.7</span> Bonus : listes en compr&#233;hension</a></li>
</ul></li>
<li><a href="#en-utilisant-les-listes-en-compr&#233;hension"><span class="toc-section-number">4</span> En utilisant les listes en compr&#233;hension</a></li>
<li><a href="#les-cha&#238;nes-de-caract&#232;res"><span class="toc-section-number">5</span> Les cha&#238;nes de caract&#232;res</a><ul>
<li><a href="#conversion-dune-cha&#238;ne-en-nombre"><span class="toc-section-number">5.1</span> Conversion d&#8217;une cha&#238;ne en nombre</a></li>
<li><a href="#analogie-avec-les-listes"><span class="toc-section-number">5.2</span> Analogie avec les listes</a></li>
<li><a href="#principales-m&#233;thodes-de-la-classe-str"><span class="toc-section-number">5.3</span> Principales m&#233;thodes de la classe <code>str</code></a></li>
</ul></li>
<li><a href="#les-dictionnaires"><span class="toc-section-number">6</span> Les dictionnaires</a><ul>
<li><a href="#modification-du-contenu-dun-dictionnaire"><span class="toc-section-number">6.1</span> Modification du contenu d&#8217;un dictionnaire</a></li>
<li><a href="#lecture-du-contenu-dun-dictionnaire"><span class="toc-section-number">6.2</span> Lecture du contenu d&#8217;un dictionnaire</a></li>
<li><a href="#parcours-dun-dictionnaire"><span class="toc-section-number">6.3</span> Parcours d&#8217;un dictionnaire</a><ul>
<li><a href="#parcours-par-valeurs"><span class="toc-section-number">6.3.1</span> Parcours par valeurs</a></li>
<li><a href="#parcours-par-cl&#233;s"><span class="toc-section-number">6.3.2</span> Parcours par cl&#233;s</a></li>
<li><a href="#parcours-par-couples-cl&#233;svaleurs"><span class="toc-section-number">6.3.3</span> Parcours par couples cl&#233;s/valeurs</a></li>
</ul></li>
</ul></li>
<li><a href="#lecture-et-&#233;criture-de-fichiers-textuels"><span class="toc-section-number">7</span> Lecture et &#233;criture de fichiers textuels</a><ul>
<li><a href="#lecture-de-fichiers-textuels"><span class="toc-section-number">7.1</span> Lecture de fichiers textuels</a><ul>
<li><a href="#fichiers-textuels-g&#233;n&#233;riques"><span class="toc-section-number">7.1.1</span> Fichiers textuels g&#233;n&#233;riques</a></li>
<li><a href="#fichiers-comma-separated-values-csv"><span class="toc-section-number">7.1.2</span> Fichiers <em>Comma-Separated Values</em> (CSV)</a></li>
</ul></li>
</ul></li>
<li><a href="#contenu-suppos&#233;-du-fichier"><span class="toc-section-number">8</span> Contenu suppos&#233; du fichier :</a></li>
<li><a href="#section"><span class="toc-section-number">9</span> 1;2;3</a></li>
<li><a href="#ab"><span class="toc-section-number">10</span> a;b</a><ul>
<li><a href="#&#233;criture-de-fichiers-textuels"><span class="toc-section-number">10.1</span> &#201;criture de fichiers textuels</a><ul>
<li><a href="#fichiers-textuels-g&#233;n&#233;riques-1"><span class="toc-section-number">10.1.1</span> Fichiers textuels g&#233;n&#233;riques</a></li>
<li><a href="#fichiers-csv"><span class="toc-section-number">10.1.2</span> Fichiers CSV</a></li>
</ul></li>
<li><a href="#manipulation-de-fichiers-en-python-avec-le-module-os"><span class="toc-section-number">10.2</span> Manipulation de fichiers en Python avec le module <code>os</code></a></li>
</ul></li>
<li><a href="#tester-son-code"><span class="toc-section-number">11</span> Tester son code</a><ul>
<li><a href="#les-erreurs-en-python"><span class="toc-section-number">11.1</span> Les erreurs en Python</a></li>
<li><a href="#les-tests-unitaires"><span class="toc-section-number">11.2</span> Les tests unitaires</a></li>
<li><a href="#le-d&#233;veloppement-pilot&#233;-par-les-tests"><span class="toc-section-number">11.3</span> Le d&#233;veloppement pilot&#233; par les tests</a></li>
</ul></li>
<li><a href="#conclusion"><span class="toc-section-number">12</span> Conclusion</a></li>
</ul>
</div>
<table>
<tbody>
<tr class="odd">
<td align="left">title: Polycopi&#233; pour le cours de Python</td>
</tr>
<tr class="even">
<td align="left">subtitle: Cours dispens&#233; &#224; l&#8217;universit&#233; de Rennes 2</td>
</tr>
<tr class="odd">
<td align="left">language: fr</td>
</tr>
<tr class="even">
<td align="left">author: Romain Tavenard</td>
</tr>
<tr class="odd">
<td align="left">rights: Creative Commons CC BY-NC-SA</td>
</tr>
</tbody>
</table>
<h1 id="introduction"><a href="#TOC"><span class="header-section-number">1</span> Introduction</a></h1>
<p>Ce document est une tentative de polycopi&#233; associ&#233; au module de Python pour la deuxi&#232;me ann&#233;e de licence MIASHS de l&#8217;Universit&#233; de Rennes 2. Il est distribu&#233; librement (sous licence <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a> plus pr&#233;cis&#233;ment) et se veut &#233;volutif, n&#8217;h&#233;sitez donc pas &#224; faire vos remarques &#224; son auteur dont vous trouverez le contact sur <a href="http://people.irisa.fr/Romain.Tavenard/">sa page web</a>.</p>
<p>Durant la lecture de ce polycopi&#233;, vous trouverez des blocs de code tels que celui-ci :</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> f(v):
    <span class="kw">return</span> v ** <span class="dv">2</span>

x = <span class="dv">5</span>
y = f(<span class="dv">3</span> * x + <span class="dv">2</span>)
<span class="kw">print</span>(y)
<span class="co"># [Sortie] 289</span></code></pre>
<p>Nous prendrons notamment l&#8217;habitude de reporter les valeurs affich&#233;es par l&#8217;ex&#233;cution du programme consid&#233;r&#233; dans un terminal avec la syntaxe utilis&#233;e &#224; la derni&#232;re ligne du code ci-dessus.</p>
<p>Dans ce document, nous allons donc nous int&#233;resser au langage Python. Pour tester les exemples pr&#233;sent&#233;s au fil de ce document ou r&#233;aliser les exercices propos&#233;s, vous aurez deux possibilit&#233;s. La premi&#232;re consiste &#224; ouvrir une <strong>console Python</strong>, &#224; l&#8217;aide de la commande suivante (si vous &#234;tes sous Unix, en supposant que le symbole <code>$</code> corresponde au prompt de votre <em>shell</em>) : <code>$ python Python 3.5.1 (default, Dec  9 2015, 11:28:16) [GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.1.76)] on darwin Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt;</code></p>
<p>Lors de l&#8217;ex&#233;cution de cette commande, on peut remarquer plusieurs choses. Tout d&#8217;abord, au d&#233;marrage, la console Python nous indique la version de Python qui est ex&#233;cut&#233;e. Cela est important, car il existe notamment une importante diff&#233;rence entre les versions 2 (2.x.y) et 3 (3.x.y) de Python. Dans ce document, nous supposons l&#8217;utilisation de Python dans sa version 3, comme dans la console affich&#233;e plus haut. Enfin, une fois la console d&#233;mar&#233;e, on voit appara&#238;tre un prompt Python (<code>&gt;&gt;&gt;</code>) qui indique que vous pouvez, &#224; partir de ce point, entrer du code Python et en demander l&#8217;ex&#233;cution en appuyant sur la touche <em>retour chariot</em> (ou &#8220;Entr&#233;e&#8221;) de votre clavier.</p>
<p>L&#8217;autre fa&#231;on de programmer en Python, plus adapt&#233;e d&#232;s lors que l&#8217;on souhaite conserver une trace de ce qu&#8217;on a &#233;crit, consiste &#224; enregistrer vos commandes dans un fichier texte (en respectant la convention qui consiste &#224; utiliser l&#8217;extension <code>.py</code> pour le nom de fichier) puis &#224; faire ex&#233;cuter votre programme par l&#8217;interpr&#233;teur Python : <code>$ python nom_de_mon_fichier.py [...]</code></p>
<h1 id="structures-de-donn&#233;es-et-structures-de-contr&#244;le"><a href="#TOC"><span class="header-section-number">2</span> Structures de donn&#233;es et structures de contr&#244;le</a></h1>
<p>Dans ce chapitre, nous allons nous int&#233;resser aux &#233;l&#233;ments de base de la syntaxe Python : les structures de donn&#233;es d&#8217;une part et les structures de contr&#244;le d&#8217;autre part. Les structures de donn&#233;es vont nous permettre de stocker dans la m&#233;moire de l&#8217;ordinateur (dans le but de les traiter ensuite) des donn&#233;es tandis que les structures de contr&#244;le vont servir &#224; d&#233;finir nos interactions avec ces donn&#233;es.</p>
<h2 id="variables"><a href="#TOC"><span class="header-section-number">2.1</span> Variables</a></h2>
<p>En Python, les donn&#233;es sont stock&#233;es dans des variables, on ne peut pas d&#233;finir de constante. Une variable est une association entre un symbole (le nom de la variable) et une valeur, cette derni&#232;re pouvant varier au cours de l&#8217;ex&#233;cution du programme. Les variables Python sont typ&#233;es dynamiquement, ce qui signifie qu&#8217;une variable, &#224; un moment donn&#233; de l&#8217;ex&#233;cution d&#8217;un programme, a un type pr&#233;cis qui lui est attribu&#233;, mais que celui-ci peut &#233;voluer au cours de l&#8217;ex&#233;cution du programme.</p>
<h3 id="types-des-variables-python"><a href="#TOC"><span class="header-section-number">2.1.1</span> Types des variables Python</a></h3>
<p>Les types de base existant en Python sont les suivants :</p>
<ul>
<li><code class="sourceCode python"><span class="dt">int</span></code> : entier ;</li>
<li><code class="sourceCode python"><span class="dt">float</span></code> : nombre &#224; virgule ;</li>
<li><code class="sourceCode python"><span class="dt">complex</span></code> : nombre complexe (peu utilis&#233; en pratique) ;</li>
<li><code class="sourceCode python"><span class="dt">str</span></code> : cha&#238;ne de caract&#232;res ;</li>
<li><code class="sourceCode python"><span class="dt">bool</span></code> : bool&#233;en (pouvant prendre les valeurs <code class="sourceCode python"><span class="ot">True</span></code> ou <code class="sourceCode python"><span class="ot">False</span></code>).</li>
</ul>
<p>De plus, il existe un type sp&#233;cial (<code class="sourceCode python">NoneType</code>) ne permettant qu&#8217;une seule valeur : la valeur <code class="sourceCode python"><span class="ot">None</span></code> qui signifie &#8220;pas de valeur&#8221; ou &#8220;valeur manquante&#8221;.</p>
<p>En Python, le type d&#8217;une variable n&#8217;est pas d&#233;clar&#233; par l&#8217;utilisateur : il est d&#233;fini par l&#8217;usage (la valeur effective que l&#8217;on d&#233;cide de stocker dans la variable en question).</p>
<p>Par exemple, l&#8217;instruction suivante en Python attribue la valeur <code class="sourceCode python"><span class="dv">12</span></code> &#224; la variable <code class="sourceCode python">v</code>, qui devient donc automatiquement de type entier : <code>python v = 12</code></p>
<p>Ainsi, les instructions suivantes ont toutes une incidence sur le type des variables consid&#233;r&#233;es : <code>python v = 12     # v est alors de type entier c = &quot;abc&quot;  # c est de type cha&#238;ne de caract&#232;res d = 'abc'  # d est &#233;galement de type cha&#238;ne de caract&#232;res            # les contenus de c et d sont identiques v = 12.    # v change de type et est d&#233;sormais de type nombre &#224; virgule</code></p>
<p>Pour v&#233;rifier le type d&#8217;une variable, il suffit d&#8217;utiliser la fonction <code>type</code> de la librairie standard : <code>python print(type(v))  # la fonction print(.) permet d'afficher                 # une information dans le terminal # [Sortie] &lt;class 'float'&gt;</code></p>
<h3 id="op&#233;ration-dassignation"><a href="#TOC"><span class="header-section-number">2.1.2</span> Op&#233;ration d&#8217;assignation</a></h3>
<p>Comme le montrent les exemples pr&#233;c&#233;dents, pour pouvoir utiliser des variables, on doit leur donner un nom (plac&#233; &#224; gauche du signe &#233;gal dans l&#8217;op&#233;ration d&#8217;affectation). Ces noms de variables doivent respecter certaines contraintes :</p>
<ul>
<li>ils doivent d&#233;buter par une lettre (minuscule ou majuscule, peu importe) ou par le symbole <code class="sourceCode python">_</code> ;</li>
<li>ils ne doivent contenir que des lettres, des chiffres et des symboles <code class="sourceCode python">_</code> ;</li>
<li>ils ne doivent pas correspondre &#224; un quelconque mot r&#233;serv&#233; du langage Python, dont voici la liste : <code>python and del for is raise assert elif from lambda return break else global not try nonlocal True False class except if or while continue import pass yield None def finally in</code></li>
<li>ils ne doivent pas correspondre &#224; des noms de fonction de la librairie standard de Python (cette derni&#232;re condition n&#8217;est en fait qu&#8217;une bonne pratique &#224; observer) : vous apprendrez au fur et &#224; mesure les noms de ces fonctions.</li>
</ul>
<p>Les noms de variable en Python sont sensibles &#224; la casse, ainsi les variables <code class="sourceCode python">maVariable</code> et <code class="sourceCode python">mavariable</code> ne pointent pas sur les m&#234;mes donn&#233;es en m&#233;moire. Pour s&#8217;en convaincre, on peut ex&#233;cuter le code suivant : <code>python mavariable = 12 maVariable = 15 print(mavariable) # [Sortie] 12 print(maVariable) # [Sortie] 15</code></p>
<p>Comme on l&#8217;a vu plus haut, on utilise en Python l&#8217;op&#233;rateur <code class="sourceCode python">=</code> pour assigner une valeur &#224; une variable. La s&#233;mantique de cet op&#233;rateur est la suivante : &#8220;assigner la valeur contenue dans le membre de droite &#224; la variable du membre de gauche&#8221;. Ainsi, il est tout &#224; fait valide d&#8217;&#233;crire, en Python : <code>python x = 3.9 * x * (1 - x)</code> Pour ex&#233;cuter cette instruction, l&#8217;interpr&#233;teur Python commencera par &#233;valuer le membre de droite en utilisant la valeur courante de la variable <code class="sourceCode python">x</code>, puis affectera la valeur correspondant au r&#233;sultat de l&#8217;op&#233;ration <code class="sourceCode python"><span class="fl">3.9</span> * x * (<span class="dv">1</span> - x)</code> dans la variable <code class="sourceCode python">x</code>.</p>
<h3 id="op&#233;rateurs-et-priorit&#233;"><a href="#TOC"><span class="header-section-number">2.1.3</span> Op&#233;rateurs et priorit&#233;</a></h3>
<p>On le voit dans l&#8217;exemple pr&#233;c&#233;dent, pour manipuler des variables, on utilisera des op&#233;rateurs (dont les plus connus sont les op&#233;rateurs arithm&#233;tiques). Le tableau suivant dresse une liste des op&#233;rateurs d&#233;finis pour les variables dont le type est l&#8217;un des types num&#233;riques (entier, nombre &#224; virgule, nombre complexe) :</p>
<p>| Op&#233;rateur | Op&#233;ration | |:&#8212;:|:&#8212;:| | <code class="sourceCode python">+</code> | Addition | | <code class="sourceCode python">-</code> | Soustraction | | <code class="sourceCode python">*</code> | Multiplication | | <code class="sourceCode python">/</code> | Division | | <code class="sourceCode python">**</code> | &#201;l&#233;vation &#224; la puissance | | <code class="sourceCode python">%</code> | Modulo (non d&#233;fini pour les nombres complexes) |</p>
<p>De plus, pour chacun de ces op&#233;rateurs, il existe un op&#233;rateur associ&#233; qui r&#233;alise successivement l&#8217;op&#233;ration demand&#233;e puis l&#8217;affectation de la nouvelle valeur &#224; la variable en question. Ainsi, l&#8217;instruction suivante : <code>python x = x + 2</code></p>
<p>qui ajoute 2 &#224; la valeur courante de <code class="sourceCode python">x</code> puis stocke le r&#233;sultat du calcul dans <code class="sourceCode python">x</code> peut se r&#233;&#233;crire : <code>python x += 2</code></p>
<p>Ceci est purement un raccourci de notation, s&#8217;il ne vous semble pas &#233;vident &#224; ma&#238;triser au premier abord, vous pouvez vous en passer et toujours utiliser la notation <code class="sourceCode python">x = x + <span class="dv">2</span></code>.</p>
<p>Enfin, lorsque l&#8217;&#233;valuation d&#8217;une expression implique plusieurs op&#233;rateurs, les r&#232;gles de priorit&#233; sont les suivantes (de la priorit&#233; maximale &#224; la priorit&#233; minimale) :</p>
<ol style="list-style-type: decimal">
<li>parenth&#232;ses ;</li>
<li>&#233;l&#233;vation &#224; la puissance ;</li>
<li>multiplication / division ;</li>
<li>addition / soustraction ;</li>
<li>de gauche &#224; droite.</li>
</ol>
<p>Pour prendre un exemple concret, pour &#233;valuer l&#8217;expression : <code>python 3.9 * x * (1 - x)</code></p>
<p>on commencera par &#233;valuer le contenu de la parenth&#232;se puis, les 2 op&#233;rations restantes &#233;tant toutes des multiplications, on les effectuera de gauche &#224; droite.</p>
<p>De plus, lorsqu&#8217;une op&#233;ration est effectu&#233;e entre deux variables de types diff&#233;rents, le type le plus g&#233;n&#233;rique est retenu. Par exemple, si l&#8217;on multiplie un entier par un nombre &#224; virgule, le r&#233;sultat sera de type <code class="sourceCode python"><span class="dt">float</span></code>. De m&#234;me, le r&#233;sultat de l&#8217;addition entre un nombre complexe et un nombre &#224; virgule est un complexe.</p>
<p><strong>Attention.</strong> Comme indiqu&#233; en introduction, ce polycopi&#233; suppose que vous utilisez Python dans sa version 3. Il est &#224; noter qu&#8217;il existe une diff&#233;rence importante entre Python 2 et Python 3 dans la fa&#231;on d&#8217;effectuer des op&#233;rations m&#234;lant nombres entiers et flottants. Par exemple, l&#8217;op&#233;ration suivante : <code>python x = 2 / 3</code></p>
<p>stockera, en Python 2, la valeur 0 (r&#233;sultat de la division <strong>enti&#232;re</strong> de 2 par 3) dans la variable <code class="sourceCode python">x</code> alors qu&#8217;en Python 3, la division <strong>flottante</strong> sera effectu&#233;e et ainsi <code class="sourceCode python">x</code> contiendra <code class="sourceCode python"><span class="fl">0.666666</span>...</code> En Python 3, si l&#8217;on souhaite effectuer une division enti&#232;re, on pourra utiliser l&#8217;op&#233;rateur <code class="sourceCode python">//</code> : <code>python print(2 // 3) # [Sortie] 0</code></p>
<h2 id="structures-de-contr&#244;le"><a href="#TOC"><span class="header-section-number">2.2</span> Structures de contr&#244;le</a></h2>
<p>Un programme est une s&#233;quence d&#8217;instructions dont l&#8217;ordre doit &#234;tre respect&#233;. Au-del&#224; de cet aspect s&#233;quentiel, on peut souhaiter :</p>
<ul>
<li>n&#8217;effectuer certaines instructions que si une condition est v&#233;rifi&#233;e ;</li>
<li>r&#233;p&#233;ter certaines instructions ;</li>
<li>factoriser une sous-s&#233;quence d&#8217;instructions au sein d&#8217;une fonction pour pouvoir y faire appel &#224; plusieurs reprises dans le programme.</li>
</ul>
<p>Les structures de contr&#244;le associ&#233;es &#224; ces diff&#233;rents comportements sont d&#233;crits dans la suite de cette section.</p>
<h3 id="structures-conditionnelles"><a href="#TOC"><span class="header-section-number">2.2.1</span> Structures conditionnelles</a></h3>
<p>On peut donc indiquer &#224; un programme de n&#8217;ex&#233;cuter une instruction (ou une s&#233;quence d&#8217;instructions) que si une certaine condition est remplie, &#224; l&#8217;aide du mot-cl&#233; <code class="sourceCode python"><span class="kw">if</span></code> : <code>python x = 12 if x &gt; 0:     print(&quot;X est positif&quot;)     print(&quot;X n'est pas n&#233;gatif&quot;) # [Sortie] X est positif # [Sortie] X n'est pas n&#233;gatif</code></p>
<p>On remarque ici que la condition est termin&#233;e par le symbole <code class="sourceCode python">:</code>, de plus, la s&#233;quence d&#8217;instructions &#224; ex&#233;cuter si la condition est remplie est <strong>indent&#233;e</strong>, cela signifie qu&#8217;elle est d&#233;cal&#233;e d&#8217;un &#8220;cran&#8221; (g&#233;n&#233;ralement une tabulation ou 4 espaces) vers la droite. Cette indentation est une bonne pratique recommand&#233;e quel que soit le langage que vous utilisez, mais en Python, c&#8217;est m&#234;me une obligation (sinon, l&#8217;interpr&#233;teur Python ne saura pas o&#249; commence et o&#249; se termine la s&#233;quence &#224; ex&#233;cuter sous condition).</p>
<p>Dans certains cas, on souhaite ex&#233;cuter une s&#233;rie d&#8217;instructions si la condition est v&#233;rifi&#233;e et une autre s&#233;rie d&#8217;instructions si elle ne l&#8217;est pas. Pour cela, on utilise le mot-cl&#233; <code class="sourceCode python"><span class="kw">else</span></code> comme suit : <code>python x = -1 if x &gt; 0:     print(&quot;X est positif&quot;)     print(&quot;X n'est pas n&#233;gatif&quot;) else:     print(&quot;X est n&#233;gatif&quot;) # [Sortie] X est n&#233;gatif</code></p>
<p>L&#224; encore, on remarque que l&#8217;indentation est de rigueur pour chacun des deux blocs d&#8217;instructions. On note &#233;galement que le mot-cl&#233; <code class="sourceCode python"><span class="kw">else</span></code> se trouve au m&#234;me niveau que le <code class="sourceCode python"><span class="kw">if</span></code> auquel il se r&#233;f&#232;re.</p>
<p>Enfin, de mani&#232;re plus g&#233;n&#233;rale, il est possible de d&#233;finir plusieurs comportements en fonction de plusieurs tests successifs, &#224; l&#8217;aide du mot-cl&#233; <code class="sourceCode python"><span class="kw">elif</span></code> : <code>python x = -1 if x &gt; 0:     print(&quot;X est positif&quot;)     x = 4 elif x &gt; -2:     print(&quot;X est compris entre -2 et 0&quot;) elif x &gt; -4:     print(&quot;X est compris entre -4 et -2&quot;) else:     print(&quot;X est inf&#233;rieur &#224; -4&quot;) # [Sortie] X est compris entre -2 et 0</code></p>
<p>Pour utiliser ces structures conditionnelles, il est important de ma&#238;triser les diff&#233;rents op&#233;rateurs de comparaison &#224; votre disposition en Python, dont voici une liste non exhaustive :</p>
<p>| Op&#233;rateur | Comparaison effectu&#233;e | Exemple | |:&#8212;:|:&#8212;:|:&#8212;:| | <code class="sourceCode python">&lt;</code> | Plus petit que | <code class="sourceCode python">x &lt; <span class="dv">0</span></code> | | <code class="sourceCode python">&gt;</code> | Plus grand que | <code class="sourceCode python">x &gt; <span class="dv">0</span></code> | | <code class="sourceCode python">&lt;=</code> | Plus petit ou &#233;gal &#224; | <code class="sourceCode python">x &lt;= <span class="dv">0</span></code> | | <code class="sourceCode python">&gt;=</code> | Plus grand ou &#233;gal &#224; | <code class="sourceCode python">x &gt;= <span class="dv">0</span></code> | | <code class="sourceCode python">==</code> | &#201;gal &#224; | <code class="sourceCode python">x == <span class="dv">0</span></code> | | <code class="sourceCode python">!=</code> | Diff&#233;rent de | <code class="sourceCode python">x != <span class="dv">0</span></code> | | <code class="sourceCode python">is</code> | Test d&#8217;&#233;galit&#233; pour le cas de la valeur <code class="sourceCode python"><span class="ot">None</span></code> | <code class="sourceCode python">x is <span class="ot">None</span></code> | | <code class="sourceCode python">is not</code> | Test d&#8217;in&#233;galit&#233; pour le cas de la valeur <code class="sourceCode python"><span class="ot">None</span></code> | <code class="sourceCode python">x is not <span class="ot">None</span></code> | | <code class="sourceCode python">in</code> | Test de pr&#233;sence d&#8217;une valeur dans une liste | <code class="sourceCode python">x in [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">7</span>]</code> |</p>
<p>Il est notamment important de remarquer que, lorsque l&#8217;on souhaite tester l&#8217;&#233;galit&#233; entre deux valeurs, l&#8217;op&#233;rateur &#224; utiliser est <code class="sourceCode python">==</code> et non <code class="sourceCode python">=</code> (qui sert &#224; affecter une valeur &#224; une variable).</p>
<h3 id="boucles"><a href="#TOC"><span class="header-section-number">2.2.2</span> Boucles</a></h3>
<p>Il existe, en Python comme dans une grande majorit&#233; des langages de programmation, deux types de boucles :</p>
<ul>
<li>les boucles qui s&#8217;ex&#233;cutent tant qu&#8217;une condition est vraie ;</li>
<li>les boucles qui r&#233;p&#232;tent la m&#234;me s&#233;rie d&#8217;instructions pour diff&#233;rentes valeurs d&#8217;une variable (appel&#233;e <strong>variable de boucle</strong>).</li>
</ul>
<h4 id="boucles-while"><a href="#TOC"><span class="header-section-number">2.2.2.1</span> Boucles <code>while</code></a></h4>
<p>Les premi&#232;res ont une syntaxe tr&#232;s similaire &#224; celle des structures conditionnelles simples : <code>python x = 0 while x &lt;= 10:     print(x)     x = 2 * x + 2 # [Sortie] 0 # [Sortie] 2 # [Sortie] 6</code></p>
<p>On voit bien ici, en analysant la sortie produite par ces quelques lignes, que le contenu de la boucle est r&#233;p&#233;t&#233; plusieurs fois. En pratique, il est r&#233;p&#233;t&#233; jusqu&#8217;&#224; ce que la variable <code class="sourceCode python">x</code> prenne une valeur sup&#233;rieure &#224; 10 (14 dans notre cas). Il faut &#234;tre tr&#232;s prudent avec ces boucles <code class="sourceCode python"><span class="kw">while</span></code> car il est tout &#224; fait possible de cr&#233;er une boucle dont le programme ne sortira jamais, comme dans l&#8217;exemple suivant :</p>
<pre class="sourceCode python"><code class="sourceCode python">x = <span class="dv">2</span>
y = <span class="dv">0</span>
<span class="kw">while</span> x &gt; <span class="dv">0</span>:
    y = y - <span class="dv">1</span>
    <span class="kw">print</span>(y)
<span class="kw">print</span>(<span class="st">&quot;Si on arrive ici, on a fini&quot;</span>)</code></pre>
<p>En effet, on a ici une boucle qui s&#8217;ex&#233;cutera tant que <code class="sourceCode python">x</code> est positif, or la valeur de cette variable est initialis&#233;e &#224; 2 et n&#8217;est pas modifi&#233;e au sein de la boucle, la condition sera donc toujours v&#233;rifi&#233;e et le programme ne sortira jamais de la boucle. Pour information, si vous vous retrouvez dans un tel cas, vous pourrez interrompre l&#8217;ex&#233;cution du programme &#224; l&#8217;aide de la combinaison de touches <code>Ctrl + C</code>.</p>
<h4 id="boucles-for"><a href="#TOC"><span class="header-section-number">2.2.2.2</span> Boucles <code>for</code></a></h4>
<p>Le second type de boucle repose en Python sur l&#8217;utilisation de listes (ou, plus g&#233;n&#233;ralement, d&#8217;it&#233;rables) dont nous reparlerons plus en d&#233;tail dans la suite de cet ouvrage. Sachez pour le moment qu&#8217;une liste est un ensemble ordonn&#233; d&#8217;&#233;l&#233;ments. On peut alors ex&#233;cuter une s&#233;rie d&#8217;instructions pour toutes les valeurs d&#8217;une liste : <code>python for x in [1, 5, 7]:     print(x) y = 2 # [Sortie] 1 # [Sortie] 5 # [Sortie] 7</code></p>
<p>Cette syntaxe revient &#224; d&#233;finir une variable <code class="sourceCode python">x</code> qui prendra successivement pour valeur chacune des valeurs de la liste <code class="sourceCode python">[<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">7</span>]</code> dans l&#8217;ordre et &#224; ex&#233;cuter le code de la boucle (ici, un appel &#224; la fonction <code class="sourceCode python"><span class="kw">print</span></code>) pour cette valeur de la variable <code class="sourceCode python">x</code>.</p>
<h3 id="fonctions"><a href="#TOC"><span class="header-section-number">2.2.3</span> Fonctions</a></h3>
<p>Nous avons d&#233;j&#224; vu dans ce qui pr&#233;c&#232;de, sans le dire, des fonctions. Par exemple, lorsque l&#8217;on &#233;crit :</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">print</span>(x)</code></pre>
<p>on demande l&#8217;appel &#224; une fonction, nomm&#233;e <code class="sourceCode python"><span class="kw">print</span></code> et prenant un <strong>argument</strong> (ici, la variable <code class="sourceCode python">x</code>). La fonction <code class="sourceCode python"><span class="kw">print</span></code> ne retourne pas de valeur, elle ne fait qu&#8217;afficher la valeur contenue dans <code class="sourceCode python">x</code> sur le terminal. D&#8217;autres fonctions, comme <code class="sourceCode python"><span class="dt">type</span></code> dont nous avons parl&#233; plus haut, <strong>retournent une valeur</strong> et cette valeur peut &#234;tre utilis&#233;e dans la suite du programme, comme dans l&#8217;exemple suivant : <code>python x = type(1)  # On stocke dans x la valeur retourn&#233;e par type y = type(2.) if x == y:     z = 1 else:     z = 2</code></p>
<h4 id="d&#233;finition-dune-fonction"><a href="#TOC"><span class="header-section-number">2.2.3.1</span> D&#233;finition d&#8217;une fonction</a></h4>
<p>Lorsqu&#8217;un ensemble d&#8217;instructions est susceptible d&#8217;&#234;tre utilis&#233; &#224; plusieurs occasions dans un ou plusieurs programmes, il est recommand&#233; de l&#8217;isoler au sein d&#8217;une fonction. Cela pr&#233;sentera les avantages suivants :</p>
<ul>
<li>en donnant un nom &#224; la fonction et en listant la liste de ses arguments, on explicite la s&#233;mantique de l&#8217;ensemble d&#8217;instructions en question, ses entr&#233;es et sorties &#233;ventuelles, ce qui rend le code beaucoup plus lisible ;</li>
<li>s&#8217;il est n&#233;cessaire d&#8217;adapter &#224; l&#8217;avenir le code pour r&#233;soudre un <em>bug</em> ou le rendre plus g&#233;n&#233;rique, vous n&#8217;aurez &#224; modifier le code qu&#8217;&#224; un endroit (dans le corps de la fonction) et non pas &#224; chaque fois que le code est r&#233;p&#233;t&#233;.</li>
</ul>
<p>Pour d&#233;finir une fonction en Python, on utilise le mot-cl&#233; <code class="sourceCode python"><span class="kw">def</span></code> : <code>python def f(x):     y = 5 * x + 2     z = x + y     return z // 2</code></p>
<p>On a ici d&#233;fini une fonction</p>
<ul>
<li>dont le nom est <code class="sourceCode python">f</code> ;</li>
<li>qui prend un seul argument, not&#233; <code class="sourceCode python">x</code> ;</li>
<li>qui retourne une valeur, comme indiqu&#233; dans la ligne d&#233;butant par le mot-cl&#233; <code class="sourceCode python"><span class="kw">return</span></code>.</li>
</ul>
<p>Il est possible, en Python, d&#8217;&#233;crire des fonctions retournant plusieurs valeurs. Pour ce faire, ces valeurs seront s&#233;par&#233;es par des virgules dans l&#8217;instruction <code class="sourceCode python"><span class="kw">return</span></code> : <code>python def f(x):     y = 5 * x + 2     z = x + y     return z // 2, y</code></p>
<p>Enfin, en l&#8217;absence d&#8217;instruction <code class="sourceCode python"><span class="kw">return</span></code>, une fonction retournera la valeur <code class="sourceCode python"><span class="ot">None</span></code>.</p>
<p>Il est &#233;galement possible d&#8217;utiliser le nom des arguments de la fonction lors de l&#8217;appel, pour ne pas risquer de se tromper dans l&#8217;ordre des arguments. Par exemple, si l&#8217;on a la fonction suivante :</p>
<p><code>python def affiche_infos_personne(poids, taille):     print(&quot;Poids: &quot;, poids)     print(&quot;Taille: &quot;, taille)</code> Les trois appels suivants sont &#233;quivalents :</p>
<pre class="sourceCode python"><code class="sourceCode python">affiche_infos_personne(<span class="dv">80</span>, <span class="dv">180</span>)
<span class="co"># [Sortie] Poids: 80</span>
<span class="co"># [Sortie] Taille: 180</span>
affiche_infos_personne(taille=<span class="dv">180</span>, poids=<span class="dv">80</span>)
<span class="co"># [Sortie] Poids: 80</span>
<span class="co"># [Sortie] Taille: 180</span>
affiche_infos_personne(poids=<span class="dv">80</span>, taille=<span class="dv">180</span>)
<span class="co"># [Sortie] Poids: 80</span>
<span class="co"># [Sortie] Taille: 180</span></code></pre>
<p>&#201;videmment, pour que cela soit vraiment utile, il est hautement recommand&#233; d&#8217;utiliser des noms d&#8217;arguments explicites lors de la d&#233;finition de vos fonctions.</p>
<h4 id="arguments-optionnels-dune-fonction"><a href="#TOC"><span class="header-section-number">2.2.3.2</span> Argument(s) optionnel(s) d&#8217;une fonction</a></h4>
<p>Certains arguments d&#8217;une fonction peuvent avoir une valeur par d&#233;faut, d&#233;cid&#233;e par la personne qui a &#233;crit la fonction. Dans ce cas, si l&#8217;utilisateur ne sp&#233;cifie pas explicitement de valeur pour ces arguments lors de l&#8217;appel &#224; la fonction, c&#8217;est la valeur par d&#233;faut qui sera utilis&#233;e dans la fonction, dans le cas contraire, la valeur sp&#233;cifi&#233;e sera utilis&#233;e.</p>
<p>Par exemple, la fonction <code class="sourceCode python"><span class="kw">print</span></code> dispose de plusieurs arguments facultatifs, comme le caract&#232;re par lequel terminer l&#8217;affichage (par d&#233;faut, un retour &#224; la ligne, <code class="sourceCode haskell"><span class="st">&quot;\n&quot;</span></code>) :</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">print</span>(<span class="st">&quot;La vie est belle&quot;</span>)
<span class="co"># [Sortie] La vie est belle</span>
<span class="kw">print</span>(<span class="st">&quot;Life is beautiful&quot;</span>)
<span class="co"># [Sortie] Life is beautiful</span>
<span class="kw">print</span>(<span class="st">&quot;La vie est belle&quot;</span>, end=<span class="st">&quot;--&quot;</span>)
<span class="kw">print</span>(<span class="st">&quot;Life is beautiful&quot;</span>, end=<span class="st">&quot;--&quot;</span>)
<span class="co"># [Sortie] La vie est belle--Life is beautiful--</span></code></pre>
<p>Lorsque vous d&#233;finissez une fonction, la syntaxe &#224; utiliser pour donner une valeur par d&#233;faut &#224; un argument est la suivante :</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> f(x, y=<span class="dv">0</span>):  <span class="co"># La valeur par d&#233;faut pour y est 0</span>
    <span class="kw">return</span> x + <span class="dv">5</span> * y</code></pre>
<p>Attention toutefois, les arguments facultatifs (<em>ie.</em> qui disposent d&#8217;une valeur par d&#233;faut) doivent imp&#233;rativement se trouver, dans la liste des arguments, apr&#232;s le dernier argument obligatoire. Ainsi, la d&#233;finition de fonction suivante <strong>n&#8217;est pas correcte</strong> :</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> f(x, y=<span class="dv">0</span>, z):
    <span class="kw">return</span> x - <span class="dv">2</span> * y + z</code></pre>
<h2 id="les-modules-en-python"><a href="#TOC"><span class="header-section-number">2.3</span> Les modules en Python</a></h2>
<p>Jusqu&#8217;&#224; pr&#233;sent, nous avons utilis&#233; des fonctions (comme <code class="sourceCode python"><span class="kw">print</span></code>) issues de la librairie standard de Python. Celles-ci sont donc charg&#233;es par d&#233;faut lorsque l&#8217;on ex&#233;cute un script Python. Toutefois, il peut &#234;tre n&#233;cessaire d&#8217;avoir acc&#232;s &#224; d&#8217;autres fonctions et/ou variables, d&#233;finies dans d&#8217;autres librairies. Pour cela, il sera utile de charger le <strong>module</strong> correspondant.</p>
<p>Prenons l&#8217;exemple du module <code class="sourceCode python">math</code> qui propose un certain nombre de fonctions math&#233;matiques usuelles (<code class="sourceCode python">sin</code> pour le calcul du sinus d&#8217;un angle, <code class="sourceCode python">sqrt</code> pour la racine carr&#233;e d&#8217;un nombre, <em>etc.</em>) ainsi que des constantes math&#233;matiques tr&#232;s utiles comme <code class="sourceCode python">pi</code>. Le code suivant charge le module en m&#233;moire puis fait appel &#224; certaines de ses fonctions et/ou variables : ```python import math</p>
<p>print(math.sin(0)) # [Sortie] 0.0 print(math.pi) # [Sortie] 3.141592653589793 print(math.cos(2 * math.pi)) # [Sortie] 1.0 print(math.sqrt(2)) # [Sortie] 1.4142135623730951 ``` Vous remarquerez ici que l&#8217;instruction d&#8217;import du module se trouve n&#233;cessairement avant les instructions faisant r&#233;f&#233;rence aux fonctions et variables de ce module, faute de quoi ces derni&#232;res ne seraient pas d&#233;finies. De mani&#232;re g&#233;n&#233;rale, vous prendrez la bonne habitude d&#8217;&#233;crire les instructions d&#8217;import en tout d&#233;but de vos fichiers Python, pour &#233;viter tout souci.</p>
<p><strong>Exercice 2.1</strong> &#201;crivez une fonction en Python qui prenne en argument une longueur <code>l</code> et retourne l&#8217;aire du triangle &#233;quilat&#233;ral de c&#244;t&#233; <code>l</code>.</p>
<p><strong>Exercice 2.2</strong> &#201;crivez une fonction en Python qui affiche tous les termes plus petits que 1000 de la suite \((u_n)\) d&#233;finie comme : \[\begin{array}{rcc}u_0 &amp; = &amp; 2 \\
\forall n \geq 1, \, u_n &amp; = &amp; u_{n-1}^2\end{array}\]</p>
<h1 id="les-listes"><a href="#TOC"><span class="header-section-number">3</span> Les listes</a></h1>
<p>En Python, les listes stockent des s&#233;quences d&#8217;&#233;l&#233;ments. Il n&#8217;est pas n&#233;cessaire que tous les &#233;l&#233;ments d&#8217;une liste soient du m&#234;me type, m&#234;me si dans les exemples que nous consid&#233;rerons, ce sera souvent le cas.</p>
<p>On peut trouver des informations pr&#233;cieuses sur le sujet des listes dans l&#8217;aide en ligne de Python disponible &#224; l&#8217;adresse : <a href="https://docs.python.org/3/tutorial/datastructures.html"><code class="url">https://docs.python.org/3/tutorial/datastructures.html</code></a>.</p>
<h2 id="avant-propos-listes-et-it&#233;rables"><a href="#TOC"><span class="header-section-number">3.1</span> Avant-propos : listes et it&#233;rables</a></h2>
<p>Dans la suite, nous parlerons de listes, qui est un type de donn&#233;es bien sp&#233;cifique en Python. Toutefois, une grande partie de notre propos pourra se transposer &#224; l&#8217;ensemble des it&#233;rables en Python (c&#8217;est-&#224;-dire l&#8217;ensemble des objets Python dont on peut parcourir les &#233;l&#233;ments un &#224; un).</p>
<p>Il existe toutefois une diff&#233;rence majeure entre listes et it&#233;rables : nous verrons dans la suite de ce chapitre que l&#8217;on peut acc&#233;der au \(i\)-&#232;me &#233;l&#233;ment d&#8217;une liste simplement, alors que ce n&#8217;est g&#233;n&#233;ralement pas possible pour un it&#233;rable (pour ce dernier, il faudra parcourir l&#8217;ensemble de ses &#233;l&#233;ments et s&#8217;arr&#234;ter lorsque l&#8217;on est effectivement rendu au \(i\)-&#232;me).</p>
<p>Toutefois, si l&#8217;on a un it&#233;rable <code class="sourceCode python">iterable</code>, il est possible de le transformer en liste simplement &#224; l&#8217;aide de la fonction <code class="sourceCode python"><span class="dt">list</span></code> : <code>python l = list(iterable)</code></p>
<h2 id="cr&#233;ation-de-liste"><a href="#TOC"><span class="header-section-number">3.2</span> Cr&#233;ation de liste</a></h2>
<p>Pour cr&#233;er une liste contenant des &#233;l&#233;ments d&#233;finis (par exemple la liste contenant les entiers 1, 5 et 7), il est possible d&#8217;utiliser la syntaxe suivante : <code>python liste = [1, 5, 7]</code> De la m&#234;me fa&#231;on, on peut cr&#233;er une liste vide (ne contenant aucun &#233;l&#233;ment) : <code>python liste = [] print(len(liste)) # [Sortie] 0</code></p>
<p>On voit ici la fonction <code class="sourceCode python"><span class="dt">len</span></code> qui retourne la taille d&#8217;une liste pass&#233;e en argument (ici 0 puisque la liste est vide).</p>
<p>Toutefois, lorsque l&#8217;on souhaite cr&#233;er des listes longues (par exemple la liste des 1000 premiers entiers), cette m&#233;thode est peu pratique. Heureusement, il existe des fonctions qui permettent de cr&#233;er de telles listes. Par exemple, la fonction <code class="sourceCode python"><span class="dt">range</span>(a, b)</code> retourne un it&#233;rable contenant les entiers de <code class="sourceCode python">a</code> (inclus) &#224; <code class="sourceCode python">b</code> (exclu) : <code>python l = range(1, 10)     # l = [1, 2, 3, ..., 9] l = range(10)        # l = [0, 1, 2, ..., 9] l = range(0, 10, 2)  # l = [0, 2, 4, ..., 8]</code> On remarque que, si l&#8217;on ne donne qu&#8217;un argument &#224; la fonction <code class="sourceCode python"><span class="dt">range</span></code>, l&#8217;it&#233;rable retourn&#233; d&#233;bute &#224; l&#8217;entier 0. Si, au contraire, on passe un troisi&#232;me argument &#224; la fonction <code class="sourceCode python"><span class="dt">range</span></code>, cet argument correspond au pas utilis&#233; entre deux &#233;l&#233;ments successifs.</p>
<h2 id="acc&#232;s-aux-&#233;l&#233;ments-dune-liste"><a href="#TOC"><span class="header-section-number">3.3</span> Acc&#232;s aux &#233;l&#233;ments d&#8217;une liste</a></h2>
<p>Pour acc&#233;der au \(i\)-&#232;me &#233;l&#233;ment d&#8217;une liste, on utilise la syntaxe : <code>python l[i]</code> Attention, toutefois, le premier indice d&#8217;une liste est 0, on a donc : <code>python l = [1, 5, 7] print(l[1]) # [Sortie] 5 print(l[0]) # [Sortie] 1</code></p>
<p>On peut &#233;galement acc&#233;der au dernier &#233;l&#233;ment d&#8217;une liste en demandant l&#8217;&#233;l&#233;ment d&#8217;indice <code class="sourceCode python">-<span class="dv">1</span></code> : <code>python l = [1, 5, 7] print(l[-1]) # [Sortie] 7 print(l[-2]) # [Sortie] 5 print(l[-3]) # [Sortie] 1</code> De la m&#234;me fa&#231;on, on peut acc&#233;der au deuxi&#232;me &#233;l&#233;ment en partant de la fin <em>via</em> l&#8217;indice <code class="sourceCode python">-<span class="dv">2</span></code>, <em>etc.</em></p>
<p>Ainsi, pour une liste de taille \(n\), les valeurs d&#8217;indice valides sont les entiers compris entre \(-n\) et \(n - 1\) (inclus).</p>
<p>Il est &#233;galement &#224; noter que l&#8217;acc&#232;s aux &#233;l&#233;ments d&#8217;une liste peut se faire en lecture (lire l&#8217;&#233;l&#233;ment stock&#233; &#224; l&#8217;indice <code class="sourceCode python">i</code>) comme en &#233;criture (modifier l&#8217;&#233;l&#233;ment stock&#233; &#224; l&#8217;indice <code class="sourceCode python">i</code>) : <code>python l = [1, 5, 7] print(l[1]) # [Sortie] 5 l[1] = 2 print(l) # [Sortie] [1, 2, 7]</code></p>
<p>Enfin, on peut acc&#233;der &#224; une sous-partie d&#8217;une liste &#224; l&#8217;aide de la syntaxe <code class="sourceCode python">l[d:f]</code> o&#249; <code class="sourceCode python">d</code> est l&#8217;indice de d&#233;but et <code class="sourceCode python">f</code> est l&#8217;indice de fin (exclu). Ainsi, on a : <code>python l = [1, 5, 7, 8, 0, 9, 8] print(l[2:4]) # [Sortie] [7, 8]</code> Lorsque l&#8217;on utilise cette syntaxe, si l&#8217;on omet l&#8217;indice de d&#233;but, la s&#233;lection commence au d&#233;but de la liste et si l&#8217;on omet l&#8217;indice de fin, elle s&#8217;&#233;tend jusqu&#8217;&#224; la fin de la liste : <code>python l = [1, 5, 7, 8, 0, 9, 8] print(l[:3]) # [Sortie] [1, 5, 7] print(l[5:]) # [Sortie] [9, 8]</code></p>
<h2 id="parcours-dune-liste"><a href="#TOC"><span class="header-section-number">3.4</span> Parcours d&#8217;une liste</a></h2>
<p>Lorsque l&#8217;on parcourt une liste, on peut vouloir acc&#233;der :</p>
<ul>
<li>aux &#233;l&#233;ments stock&#233;s dans la liste uniquement ;</li>
<li>aux indices de la liste uniquement (m&#234;me si c&#8217;est rare) ;</li>
<li>aux indices de la listes et aux &#233;l&#233;ments associ&#233;s.</li>
</ul>
<p>Ces trois cas de figure impliquent trois parcours de liste diff&#233;rents, d&#233;crits dans ce qui suit.</p>
<p><strong>Attention.</strong> Quel que soit le parcours de liste utilis&#233;, il est fortement d&#233;conseill&#233; de supprimer ou d&#8217;ins&#233;rer des &#233;l&#233;ments dans une liste pendant le parcours de celle-ci.</p>
<h3 id="parcours-des-&#233;l&#233;ments"><a href="#TOC"><span class="header-section-number">3.4.1</span> Parcours des &#233;l&#233;ments</a></h3>
<p>Pour parcourir les &#233;l&#233;ments d&#8217;une liste, on utilise une boucle <code class="sourceCode python"><span class="kw">for</span></code> : <code>python l = [1, 5, 7] for elem in l:     print(elem) # [Sortie] 1 # [Sortie] 5 # [Sortie] 7</code></p>
<h3 id="parcours-par-indices"><a href="#TOC"><span class="header-section-number">3.4.2</span> Parcours par indices</a></h3>
<p>Pour avoir acc&#232;s aux indices (positifs) de la liste, on devra utiliser un subterfuge. On sait que les indices d&#8217;une liste sont les entiers compris entre 0 (inclus) et la taille de la liste (exclu). On va donc utiliser la fonction <code class="sourceCode python"><span class="dt">range</span></code> pour cela : <code>python l = [1, 5, 7] n = len(l)  # n = 3 ici for i in range(n):     print(i) # [Sortie] 0 # [Sortie] 1 # [Sortie] 2</code></p>
<h3 id="parcours-par-&#233;l&#233;ments-et-indices"><a href="#TOC"><span class="header-section-number">3.4.3</span> Parcours par &#233;l&#233;ments et indices</a></h3>
<p>Dans certains cas, enfin, on a besoin de manipuler simultan&#233;ment les indices d&#8217;une listes et les &#233;l&#233;ments associ&#233;s. Cela se fait &#224; l&#8217;aide de la fonction <code class="sourceCode python"><span class="dt">enumerate</span></code> : <code>python l = [1, 5, 7] for i, elem in enumerate(l):     print(i, elem) # [Sortie] 0 1 # [Sortie] 1 5 # [Sortie] 2 7</code></p>
<p>On a donc ici une boucle <code class="sourceCode python"><span class="kw">for</span></code> pour laquelle, &#224; chaque it&#233;ration, on met &#224; jour les variables <code class="sourceCode python">i</code> (qui contient l&#8217;indice courant) et <code class="sourceCode python">elem</code> (qui contient l&#8217;&#233;l&#233;ment se trouvant &#224; l&#8217;indice <code class="sourceCode python">i</code> dans la liste <code class="sourceCode python">l</code>).</p>
<p><strong>Exercice 3.1</strong> &#201;crivez une fonction en Python qui permette de calculer l&#8217;argmax d&#8217;une liste, c&#8217;est-&#224;-dire l&#8217;indice auquel est stock&#233;e la valeur maximale de la liste.</p>
<h2 id="manipulations-de-listes"><a href="#TOC"><span class="header-section-number">3.5</span> Manipulations de listes</a></h2>
<p>Nous pr&#233;sentons dans ce qui suit les op&#233;rations &#233;l&#233;mentaires de manipulation de listes.</p>
<h3 id="insertion-d&#233;l&#233;ment"><a href="#TOC"><span class="header-section-number">3.5.1</span> Insertion d&#8217;&#233;l&#233;ment</a></h3>
<p>Pour ins&#233;rer un nouvel &#233;l&#233;ment dans une liste, on peut :</p>
<ul>
<li>rajouter un &#233;l&#233;ment &#224; la fin de la liste &#224; l&#8217;aide de la m&#233;thode <code class="sourceCode python">append</code> ;</li>
<li>ins&#233;rer un &#233;l&#233;ment &#224; l&#8217;indice <code class="sourceCode python">i</code> de la liste &#224; l&#8217;aide de la m&#233;thode <code class="sourceCode python">insert</code>.</li>
</ul>
<p>Comme vous pouvez le remarquer, il est ici question de m&#233;thodes et non plus de fonctions. Pour l&#8217;instant, sachez que les m&#233;thodes sont des fonctions sp&#233;cifiques &#224; certains objets, comme les listes par exemples. L&#8217;appel de ces m&#233;thodes est un peu particulier, comme vous pouvez le remarquer dans ce qui suit : <code>python l = [1, 5, 7] l.append(2) print(l) # [Sortie] [1, 5, 7, 2] l.insert(2, 0)  # ins&#232;re la valeur 0 &#224; l'indice 2 print(l) # [Sortie] [1, 5, 0, 7, 2]</code></p>
<h3 id="suppression-d&#233;l&#233;ment"><a href="#TOC"><span class="header-section-number">3.5.2</span> Suppression d&#8217;&#233;l&#233;ment</a></h3>
<p>Si l&#8217;on souhaite, maintenant, supprimer un &#233;l&#233;ment dans une liste, deux cas de figures peuvent se pr&#233;senter. On peut souhaiter :</p>
<ul>
<li>supprimer l&#8217;&#233;l&#233;ment situ&#233; &#224; l&#8217;indice <code class="sourceCode python">i</code> dans la liste, &#224; l&#8217;aide de la m&#233;thode <code class="sourceCode python">pop</code> ;</li>
<li>supprimer la premi&#232;re occurrence d&#8217;une valeur donn&#233;e dans la liste &#224; l&#8217;aide de la m&#233;thode <code class="sourceCode python">remove</code>.</li>
</ul>
<pre class="sourceCode python"><code class="sourceCode python">l = [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">7</span>]
l.pop(<span class="dv">1</span>)  <span class="co"># l&#39;&#233;l&#233;ment d&#39;indice 1 est le deuxi&#232;me &#233;l&#233;ment de la liste !</span>
<span class="kw">print</span>(l)
<span class="co"># [Sortie] [1, 7]</span>
l.pop()  <span class="co"># par d&#233;faut, supprime le dernier &#233;l&#233;ment de la liste</span>
<span class="kw">print</span>(l)
<span class="co"># [Sortie] [1]</span>
l = [<span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">1</span>]
l.remove(<span class="dv">1</span>)
<span class="kw">print</span>(l)
<span class="co"># [Sortie] [7, 5]</span></code></pre>
<p>On peut noter que la m&#233;thode <code class="sourceCode python">pop</code> retourne la valeur supprim&#233;e, ce qui peut s&#8217;av&#233;rer utile : <code>python l = [1, 5, 7] v = l.pop(1) print(v) # [Sortie] 5 print(l) # [Sortie] [1, 7]</code></p>
<h3 id="recherche-d&#233;l&#233;ment"><a href="#TOC"><span class="header-section-number">3.5.3</span> Recherche d&#8217;&#233;l&#233;ment</a></h3>
<p>Pour trouver l&#8217;indice de la premi&#232;re occurrence d&#8217;une valeur dans une liste, on utilisera la m&#233;thode <code class="sourceCode python">index</code> : <code>python l = [1, 5, 7] print(l.index(7)) # [Sortie] 2</code></p>
<p>Si l&#8217;on ne cherche pas &#224; conna&#238;tre la position d&#8217;une valeur dans une liste mais simplement &#224; savoir si une valeur est pr&#233;sente dans la liste, on peut utiliser le mot-cl&#233; <code class="sourceCode python">in</code> : <code>python l = [1, 5, 7] if 5 in l:     print(&quot;5 est dans l&quot;) # [Sortie] 5 est dans l</code></p>
<h3 id="cr&#233;ation-de-listes-composites"><a href="#TOC"><span class="header-section-number">3.5.4</span> Cr&#233;ation de listes composites</a></h3>
<p>On peut &#233;galement concat&#233;ner deux listes (c&#8217;est-&#224;-dire mettre bout &#224; bout leur contenu) &#224; l&#8217;aide de l&#8217;op&#233;rateur <code class="sourceCode python">+</code> : <code>python l1 = [1, 5, 7] l2 = [3, 4] l = l1 + l2 print(l) # [Sortie] [1, 5, 7, 3, 4]</code></p>
<p>Dans le m&#234;me esprit, l&#8217;op&#233;rateur <code class="sourceCode python">*</code> peut aussi &#234;tre utilis&#233; pour des listes : <code>python l1 = [1, 5] l2 = 3 * l1 print(l2) # [Sortie] [1, 5, 1, 5, 1, 5]</code></p>
<p>Bien entendu, vu le sens de cet op&#233;rateur, on ne peut multiplier une liste que par un entier.</p>
<h3 id="tri-de-liste"><a href="#TOC"><span class="header-section-number">3.5.5</span> Tri de liste</a></h3>
<p>Enfin, on peut trier les &#233;l&#233;ments contenus dans une liste &#224; l&#8217;aide de la fonction <code class="sourceCode python"><span class="dt">sorted</span></code> : <code>python l = [4, 5, 2] l2 = sorted(l) print(l2) # [Sortie] [2, 4, 5]</code></p>
<p><strong>Exercice 3.2</strong> &#201;crivez une fonction qui prenne deux listes en entr&#233;e et retourne l&#8217;intersection des deux listes (c&#8217;est-&#224;-dire une liste contenant tous les &#233;l&#233;ments pr&#233;sents dans les deux listes).</p>
<p><strong>Exercice 3.3</strong> &#201;crivez une fonction qui prenne deux listes en entr&#233;e et retourne l&#8217;union des deux listes (c&#8217;est-&#224;-dire une liste contenant tous les &#233;l&#233;ments pr&#233;sents dans au moins une des deux listes) sans doublon.</p>
<h2 id="copie-de-liste"><a href="#TOC"><span class="header-section-number">3.6</span> Copie de liste</a></h2>
<p>Pour la plupart des variables, en Python, la copie ne pose pas de probl&#232;me : <code>python a = 12 b = a a = 5 print(a, b) # [Sortie] 5 12</code></p>
<p>Cela ne se passe pas de la m&#234;me fa&#231;on pour les listes. En effet, si <code class="sourceCode python">l</code> est une liste, lorsque l&#8217;on &#233;crit : <code>python l2 = l</code> on ne recopie pas le contenu de <code class="sourceCode python">l</code> dans <code class="sourceCode python">l2</code>, mais on cr&#233;e une variable <code class="sourceCode python">l2</code> qui va &#8220;pointer&#8221; vers la m&#234;me position dans la m&#233;moire de votre ordinateur que <code class="sourceCode python">l</code>. La diff&#233;rence peut sembler mince, mais cela signifie que si l&#8217;on modifie <code class="sourceCode python">l</code> m&#234;me apr&#232;s l&#8217;instruction <code class="sourceCode python">l2 = l</code>, la modification sera r&#233;percut&#233;e sur <code class="sourceCode python">l2</code> : <code>python l = [1, 5, 7] l2 = l l[1] = 2 print(l, l2) # [Sortie] [1, 2, 7] [1, 2, 7]</code></p>
<p>Lorsque l&#8217;on souhaite &#233;viter ce comportement, il faut effectuer une copie explicite de liste, &#224; l&#8217;aide par exemple de la fonction <code class="sourceCode python"><span class="dt">list</span></code> : <code>python l = [1, 5, 7] l2 = list(l) l[1] = 2 print(l, l2) # [Sortie] [1, 2, 7] [1, 5, 7]</code></p>
<h2 id="bonus-listes-en-compr&#233;hension"><a href="#TOC"><span class="header-section-number">3.7</span> Bonus : listes en compr&#233;hension</a></h2>
<p>Il est possible de cr&#233;er des listes en filtrant et/ou modifiant certains &#233;l&#233;ments d&#8217;autres listes ou it&#233;rables. Supposons par exemple que l&#8217;on souhaite cr&#233;er la liste des carr&#233;s des 10 premiers entiers naturels. Le code qui suit pr&#233;sente deux fa&#231;ons &#233;quivalentes de cr&#233;er une telle liste : ```python # Fa&#231;on &#8220;classique&#8221; l = [] for i in range(10): l.append(i ** 2) print(l) # [Sortie] [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</p>
<h1 id="en-utilisant-les-listes-en-compr&#233;hension"><a href="#TOC"><span class="header-section-number">4</span> En utilisant les listes en compr&#233;hension</a></h1>
<p>l = [i ** 2 for i in range(10)] print(l) # [Sortie] [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] ```</p>
<p>On remarque que la syntaxe de liste en compr&#233;hension est plus compacte. On peut &#233;galement appliquer un filtre sur les &#233;l&#233;ments de la liste de d&#233;part (ici <code class="sourceCode python"><span class="dt">range</span>(<span class="dv">10</span>)</code>) &#224; consid&#233;rer &#224; l&#8217;aide du mot-cl&#233; <code class="sourceCode python"><span class="kw">if</span></code> : <code>python l = [i ** 2 for i in range(10) if i % 2 == 0] print(l) # [Sortie] [0, 4, 16, 36, 64]</code> Ici, on n&#8217;a consid&#233;r&#233; que les entiers pairs.</p>
<h1 id="les-cha&#238;nes-de-caract&#232;res"><a href="#TOC"><span class="header-section-number">5</span> Les cha&#238;nes de caract&#232;res</a></h1>
<p>Nous nous int&#233;ressons maintenant &#224; un autre type de donn&#233;es particulier du langage Python : les cha&#238;nes de caract&#232;res (type <code class="sourceCode python"><span class="dt">str</span></code>). Pour cr&#233;er une cha&#238;ne de caract&#232;res, il suffit d&#8217;utiliser des guillemets, simples ou doubles (les deux sont &#233;quivalents) : <code>python s1 = &quot;abc&quot; s2 = 'bde'</code></p>
<p>Comme pour les listes (et peut-&#234;tre m&#234;me plus encore), il est fortement conseill&#233; de se reporter &#224; l&#8217;aide en ligne d&#233;di&#233;e lorsque vous avez des doutes sur la manipulation de cha&#238;nes de caract&#232;res : <a href="https://docs.python.org/3/library/stdtypes.html#string-methods"><code class="url">https://docs.python.org/3/library/stdtypes.html#string-methods</code></a></p>
<h2 id="conversion-dune-cha&#238;ne-en-nombre"><a href="#TOC"><span class="header-section-number">5.1</span> Conversion d&#8217;une cha&#238;ne en nombre</a></h2>
<p>Si une cha&#238;ne de caract&#232;res repr&#233;sente une valeur num&#233;rique (comme la cha&#238;ne <code class="sourceCode haskell"><span class="st">&quot;10.2&quot;</span></code> par exemple), on peut la transformer en un entier ou un nombre &#224; virgule, afin de l&#8217;utiliser ensuite pour des op&#233;rations arithm&#233;tiques : <code>python s = '10.2' f = float(s) print(f) # [Sortie] 10.2 print(f == s) # [Sortie] False print(f + 2) # [Sortie] 12.2</code></p>
<pre class="sourceCode python"><code class="sourceCode python">s = <span class="st">&#39;10&#39;</span>
i = <span class="dt">int</span>(s)
<span class="kw">print</span>(i)
<span class="co"># [Sortie] 10</span>
<span class="kw">print</span>(i == s)
<span class="co"># [Sortie] False</span>
<span class="kw">print</span>(i - <span class="dv">1</span>)
<span class="co"># [Sortie] 9</span></code></pre>
<h2 id="analogie-avec-les-listes"><a href="#TOC"><span class="header-section-number">5.2</span> Analogie avec les listes</a></h2>
<p>Les cha&#238;nes de caract&#232;res se manipulent en partie comme des listes. On peut ainsi obtenir la taille d&#8217;une cha&#238;ne de caract&#232;res &#224; l&#8217;aide de la fonction <code class="sourceCode python"><span class="dt">len</span></code>, ou acc&#233;der &#224; la \(i\)-&#232;me lettre d&#8217;une cha&#238;ne de caract&#232;res avec la notation <code class="sourceCode python">s[i]</code>. Comme pour les listes, il est possible d&#8217;indicer une cha&#238;ne de caract&#232;res en partant de la fin, en utilisant des indices n&#233;gatifs : <code>python s = &quot;abcdef&quot; print(s[0]) # [Sortie] a print(s[-1]) # [Sortie] f</code></p>
<p>De m&#234;me, on peut s&#233;lectionner des sous-parties de cha&#238;nes de caract&#232;res &#224; partir des indices de d&#233;but et de fin de la s&#233;lection. Comme pour les listes, l&#8217;indice de fin correspond au premier &#233;l&#233;ment exclu de la s&#233;lection : <code>python s = &quot;abcdef&quot; print(s[2:4]) # [Sortie] cd</code></p>
<p>Comme pour les listes, on peut concat&#233;ner deux cha&#238;nes de caract&#232;res &#224; l&#8217;aide de l&#8217;op&#233;rateur <code class="sourceCode python">+</code> ou r&#233;p&#233;ter une cha&#238;ne de caract&#232;res avec l&#8217;op&#233;rateur <code class="sourceCode python">*</code> : <code>python s = &quot;ab&quot; + ('cde' * 3) print(s) # [Sortie] abcdecdecde</code></p>
<p>On peut &#233;galement tester la pr&#233;sence d&#8217;une sous-cha&#238;ne de caract&#232;res dans une cha&#238;ne avec le mot-cl&#233; <code class="sourceCode python">in</code> : <code>python s = &quot;abcde&quot; print(&quot;a&quot; in s) # [Sortie] True print(&quot;bcd&quot; in s) # [Sortie] True print(&quot;bCd&quot; in s) # [Sortie] False</code></p>
<p><strong>Attention.</strong> Toutefois, l&#8217;analogie entre listes et cha&#238;nes de caract&#232;res est loin d&#8217;&#234;tre parfaite. Par exemple, on peut acc&#233;der au \(i\)-&#232;me &#233;l&#233;ment d&#8217;une cha&#238;ne de caract&#232;res en lecture, mais pas en &#233;criture. Si <code class="sourceCode python">s</code> est une cha&#238;ne de caract&#232;res, on ne peut pas ex&#233;cuter <code class="sourceCode python">s[<span class="dv">2</span>] = <span class="st">&quot;c&quot;</span></code> par exemple.</p>
<h2 id="principales-m&#233;thodes-de-la-classe-str"><a href="#TOC"><span class="header-section-number">5.3</span> Principales m&#233;thodes de la classe <code>str</code></a></h2>
<p>La liste de m&#233;thodes de la classe <code class="sourceCode python"><span class="dt">str</span></code> qui suit n&#8217;est pas exhaustive, il est conseill&#233; de consulter l&#8217;aide en ligne de Python pour plus d&#8217;informations.</p>
<ul>
<li><code class="sourceCode python">ch.count(sub)</code>: Retourne le nombre d&#8217;occurrences de <code class="sourceCode python">sub</code> dans <code class="sourceCode python">ch</code></li>
<li><code class="sourceCode python">ch.endswith(suffix)</code>: Retourne <code class="sourceCode python"><span class="ot">True</span></code> si <code class="sourceCode python">ch</code> se termine par <code class="sourceCode python">suffix</code></li>
<li><code class="sourceCode python">ch.startswith(prefix)</code>: Retourne <code class="sourceCode python"><span class="ot">True</span></code> si <code class="sourceCode python">ch</code> commence par <code class="sourceCode python">suffix</code></li>
<li><code class="sourceCode python">ch.find(sub)</code>: Retourne l&#8217;indice du d&#233;but de la premi&#232;re occurrence de <code class="sourceCode python">sub</code> dans <code class="sourceCode python">ch</code></li>
<li><code class="sourceCode python">ch.rfind(sub)</code>: Retourne l&#8217;indice du d&#233;but de la derni&#232;re occurrence de <code class="sourceCode python">sub</code> dans <code class="sourceCode python">ch</code></li>
<li><code class="sourceCode python">ch.islower()</code>: Retourne <code class="sourceCode python"><span class="ot">True</span></code> si <code class="sourceCode python">ch</code> est constitu&#233;e uniquement de caract&#232;res minuscules</li>
<li><code class="sourceCode python">ch.isupper()</code>: Retourne <code class="sourceCode python"><span class="ot">True</span></code> si <code class="sourceCode python">ch</code> est constitu&#233;e uniquement de caract&#232;res majuscules</li>
<li><code class="sourceCode python">ch.isnumeric()</code>: Retourne <code class="sourceCode python"><span class="ot">True</span></code> si <code class="sourceCode python">ch</code> est constitu&#233;e uniquement de chiffres</li>
<li><code class="sourceCode python">ch.lower()</code>: Retourne la version minuscule de <code class="sourceCode python">ch</code></li>
<li><code class="sourceCode python">ch.upper()</code>: Retourne la version majuscule de <code class="sourceCode python">ch</code></li>
<li><code class="sourceCode python">ch.replace(old, new)</code>: Retourne une copie de <code class="sourceCode python">ch</code> dans laquelle la <em>premi&#232;re</em> occurrence de <code class="sourceCode python">old</code> a &#233;t&#233; remplac&#233;e par <code class="sourceCode python">new</code></li>
<li><code class="sourceCode python">ch.split(sep=<span class="ot">None</span>)</code>: Retourne une liste contenant des morceaux de <code class="sourceCode python">ch</code> d&#233;coup&#233;e &#224; chaque occurrence de <code class="sourceCode python">sep</code> (n&#8217;importe quel espace par d&#233;faut)</li>
<li><code class="sourceCode python">ch.strip()</code>: Retourne une version &#8220;nettoy&#233;e&#8221; de <code class="sourceCode python">ch</code> dans laquelle on a enlev&#233; tous les espaces en d&#233;but et en fin de cha&#238;ne</li>
</ul>
<p><strong>Exercice 4.1</strong> &#201;crivez une fonction qui prenne en argument deux cha&#238;nes de caract&#232;res <code class="sourceCode python">s</code> et <code class="sourceCode python">prefix</code> et retourne le nombre de mots de la cha&#238;ne <code class="sourceCode python">s</code> qui d&#233;butent par la cha&#238;ne <code class="sourceCode python">prefix</code>.</p>
<p><strong>Exercice 4.2</strong> &#201;crivez une fonction qui prenne en argument deux cha&#238;nes de caract&#232;res <code class="sourceCode python">s</code> et <code class="sourceCode python">mot_cible</code> et retourne le nombre d&#8217;occurrences du mot <code class="sourceCode python">mot_cible</code> dans la cha&#238;ne <code class="sourceCode python">s</code> en ne tenant pas compte de la casse.</p>
<h1 id="les-dictionnaires"><a href="#TOC"><span class="header-section-number">6</span> Les dictionnaires</a></h1>
<p>Comme une liste, un dictionnaire est une collection de donn&#233;es. Mais, &#224; la diff&#233;rence des listes, les dictionnaires ne sont pas ordonn&#233;s (ou, tout du moins, ils le sont dans un ordre qui ne nous est pas naturel). Chaque entr&#233;e dans un dictionnaire est une association entre une <strong>cl&#233;</strong> (&#233;quivalente &#224; un indice pour une liste) et une <strong>valeur</strong>. Alors que les indices d&#8217;une liste sont forc&#233;ment les entiers compris entre 0 et la taille de la liste exclue, les cl&#233;s d&#8217;un dictionnaire sont des valeurs quelconques, la seule contrainte &#233;tant qu&#8217;on ne peut pas avoir deux fois la m&#234;me cl&#233; dans un dictionnaire. Notamment, ces cl&#233;s ne sont pas n&#233;cessairement des entiers, on utilisera en effet souvent des dictionnaires lorsque l&#8217;on souhaite stocker des valeurs associ&#233;es &#224; des cha&#238;nes de caract&#232;res (qui seront les cl&#233;s du dictionnaire).</p>
<p>Pour d&#233;finir un dictionnaire par ses paires cl&#233;-valeur en Python, on peut utiliser la syntaxe suivante : <code>python mon_dico = {&quot;a&quot; : 123, &quot;z&quot; : 7, &quot;bbb&quot; : None} print(mon_dico) # [Sortie] {'a': 123, 'bbb': None, 'z': 7}</code></p>
<p>On remarque ici que l&#8217;ordre dans lequel on a entr&#233; des paires cl&#233;-valeur n&#8217;est pas conserv&#233; lors de l&#8217;affichage.</p>
<h2 id="modification-du-contenu-dun-dictionnaire"><a href="#TOC"><span class="header-section-number">6.1</span> Modification du contenu d&#8217;un dictionnaire</a></h2>
<p>Pour modifier la valeur associ&#233;e &#224; une cl&#233; d&#8217;un dictionnaire, la syntaxe est similaire &#224; celle utilis&#233;e pour les listes, en rempla&#231;ant les indices par les cl&#233;s : <code>python mon_dico = {&quot;a&quot; : 123, &quot;z&quot; : 7, &quot;bbb&quot; : None} mon_dico[&quot;a&quot;] = 1000 print(mon_dico) # [Sortie] {'a': 1000, 'bbb': None, 'z': 7}</code></p>
<p>De m&#234;me, on peut cr&#233;er une nouvelle paire cl&#233;-valeur en utilisant la m&#234;me syntaxe : <code>python mon_dico = {&quot;a&quot; : 123, &quot;z&quot; : 7, &quot;bbb&quot; : None} mon_dico[&quot;c&quot;] = -1 print(mon_dico) # [Sortie] {'c': -1, 'a': 123, 'bbb': None, 'z': 7}</code></p>
<p>Enfin, pour supprimer une paire cl&#233;-valeur d&#8217;un dictionnaire, on utilise le mot-cl&#233; <code class="sourceCode python"><span class="kw">del</span></code> : <code>python mon_dico = {&quot;a&quot; : 123, &quot;z&quot; : 7, &quot;bbb&quot; : None} del mon_dico[&quot;a&quot;] print(mon_dico) # [Sortie] {'bbb': None, 'z': 7}</code></p>
<h2 id="lecture-du-contenu-dun-dictionnaire"><a href="#TOC"><span class="header-section-number">6.2</span> Lecture du contenu d&#8217;un dictionnaire</a></h2>
<p>Pour lire la valeur associ&#233;e &#224; une cl&#233; du dictionnaire, on peut utiliser la m&#234;me syntaxe que pour les listes : <code>python mon_dico = {&quot;a&quot; : 123, &quot;z&quot; : 7, &quot;bbb&quot; : None} print(mon_dico[&quot;a&quot;]) # [Sortie] 123</code></p>
<p>Par contre, si la cl&#233; demand&#233;e n&#8217;existe pas, cela g&#233;n&#232;rera une erreur. Pour &#233;viter cela, on peut utiliser la m&#233;thode <code class="sourceCode python">get</code> qui permet de d&#233;finir une valeur par d&#233;faut &#224; retourner si la cl&#233; n&#8217;existe pas : <code>python mon_dico = {&quot;a&quot; : 123, &quot;z&quot; : 7, &quot;bbb&quot; : None} print(mon_dico.get(&quot;a&quot;, 0)) # [Sortie] 123 print(mon_dico.get(&quot;b&quot;, 0)) # [Sortie] 0</code></p>
<h2 id="parcours-dun-dictionnaire"><a href="#TOC"><span class="header-section-number">6.3</span> Parcours d&#8217;un dictionnaire</a></h2>
<p>Pour parcourir le contenu d&#8217;un dictionnaire, il existe, comme pour les listes, trois possibilit&#233;s.</p>
<h3 id="parcours-par-valeurs"><a href="#TOC"><span class="header-section-number">6.3.1</span> Parcours par valeurs</a></h3>
<p>Si l&#8217;on souhaite uniquement acc&#233;der aux valeurs stock&#233;es dans le dictionnaire, on utilisera la m&#233;thode <code class="sourceCode python">values</code> : <code>python mon_dico = {&quot;a&quot; : 123, &quot;z&quot; : 7, &quot;bbb&quot; : None} for val in mon_dico.values():     print(val) # [Sortie] 123 # [Sortie] None # [Sortie] 7</code></p>
<h3 id="parcours-par-cl&#233;s"><a href="#TOC"><span class="header-section-number">6.3.2</span> Parcours par cl&#233;s</a></h3>
<p>Si l&#8217;on souhaite uniquement acc&#233;der aux cl&#233;s stock&#233;es dans le dictionnaire, on utilisera la m&#233;thode <code class="sourceCode python">keys</code> : <code>python mon_dico = {&quot;a&quot; : 123, &quot;z&quot; : 7, &quot;bbb&quot; : None} for cle in mon_dico.keys():     print(cle) # [Sortie] a # [Sortie] bbb # [Sortie] z</code></p>
<h3 id="parcours-par-couples-cl&#233;svaleurs"><a href="#TOC"><span class="header-section-number">6.3.3</span> Parcours par couples cl&#233;s/valeurs</a></h3>
<p>Si l&#8217;on souhaite acc&#233;der simultan&#233;ment aux cl&#233;s stock&#233;es dans le dictionnaire et aux valeurs associ&#233;es, on utilisera la m&#233;thode <code class="sourceCode python">items</code> : <code>python mon_dico = {&quot;a&quot; : 123, &quot;z&quot; : 7, &quot;bbb&quot; : None} for cle, valeur in mon_dico.items():     print(cle, valeur) # [Sortie] a 123 # [Sortie] bbb None # [Sortie] z 7</code></p>
<p><strong>Exercice 5.1</strong> &#201;crivez une fonction qui compte le nombre d&#8217;occurrences de chacun des mots d&#8217;une cha&#238;ne de caract&#232;res et retourne le r&#233;sultat sous forme de dictionnaire : <code>python # [...] print(compte_occurrences(&quot;la vie est belle c'est la vie&quot;)) # [Sortie] {&quot;c'est&quot;: 1, 'la': 2, 'belle': 1, 'est': 1, 'vie': 2}</code></p>
<p><strong>Exercice 5.2</strong> &#201;crivez une fonction qui retourne la somme des <em>valeurs</em> d&#8217;un dictionnaire fourni en argument.</p>
<h1 id="lecture-et-&#233;criture-de-fichiers-textuels"><a href="#TOC"><span class="header-section-number">7</span> Lecture et &#233;criture de fichiers textuels</a></h1>
<p>Dans ce chapitre, nous nous int&#233;ressons &#224; la lecture/&#233;criture de fichiers textuels par un programme Python. Un premier &#233;l&#233;ment qu&#8217;il est n&#233;cessaire de ma&#238;triser pour lire ou &#233;crire des fichiers textuels est la notion d&#8217;encodage. Il faut savoir qu&#8217;il existe plusieurs fa&#231;ons d&#8217;encoder un texte. Nous nous focaliserons ici sur les deux encodages que vous &#234;tes les plus susceptibles de rencontrer (mais sachez qu&#8217;il en existe bien d&#8217;autres) :</p>
<ul>
<li>l&#8217;encodage Unicode 8 bits (UTF-8), dont le code en python est <code class="sourceCode haskell"><span class="st">&quot;utf-8&quot;</span></code> ;</li>
<li>l&#8217;encodage Latin-1 (ISO-8859-1) dont le code en python est <code class="sourceCode haskell"><span class="st">&quot;iso-8859-1&quot;</span></code>.</li>
</ul>
<p>La principale diff&#233;rence entre ces deux encodage r&#233;side dans leur fa&#231;on de coder les accents. Ainsi, si le texte que vous lisez/&#233;crivez ne contient aucun accent ou caract&#232;re sp&#233;cial, il est probable que la question de l&#8217;encodage ne soit pas probl&#233;matique dans votre cas. Au contraire, s&#8217;il est possible que vous utilisiez de tels caract&#232;res, il faudra bien faire attention &#224; l&#8217;encodage utilis&#233;, que vous sp&#233;cifierez &#224; l&#8217;ouverture du fichier. Si votre programme doit lire un fichier, il faudra donc vous assurer de l&#8217;encodage associ&#233; &#224; ce fichier (en l&#8217;ouvrant par exemple avec un &#233;diteur de texte qui soit suffisamment avanc&#233; pour vous fournir cette information). Si vous &#233;crivez un programme qui &#233;crit un fichier, il faudra vous poser la question de l&#8217;utilisation future qui sera faite de ce fichier : s&#8217;il est amen&#233; &#224; &#234;tre ouvert par un autre utilisateur, il serait pertinent de vous demander quel encodage sera le moins probl&#233;matique pour cet utilisateur, par exemple.</p>
<p>Si vous n&#8217;avez pas de contrainte ext&#233;rieure pour ce qui est de l&#8217;encodage, vous utiliserez l&#8217;encodage UTF-8 par d&#233;faut.</p>
<h2 id="lecture-de-fichiers-textuels"><a href="#TOC"><span class="header-section-number">7.1</span> Lecture de fichiers textuels</a></h2>
<p>Ce que nous apellons lecture de fichiers textuels en Python consiste &#224; copier le contenu d&#8217;un fichier dans une (ou plusieurs) cha&#238;ne(s) de caract&#232;res. Cela implique deux &#233;tapes en Python :</p>
<ol style="list-style-type: decimal">
<li>ouvrir le fichier en lecture ;</li>
<li>parcourir le contenu du fichier.</li>
</ol>
<p>La premi&#232;re &#233;tape d&#8217;ouverture du fichier en lecture est commune &#224; tous les types de fichiers textuels. En supposant que le nom du fichier &#224; ouvrir soit stock&#233; sous forme de cha&#238;ne de caract&#232;res dans la variable <code class="sourceCode python">nom_fichier</code>, le code suivant ouvre un fichier en lecture avec l&#8217;encodage UTF-8 et stocke dans la variable <code class="sourceCode python">fp</code> un pointeur sur l&#8217;endroit o&#249; nous sommes rendus dans notre lecture du fichier (pour l&#8217;instant, le d&#233;but du fichier) : <code>python fp = open(nom_fichier, &quot;r&quot;, encoding=&quot;utf-8&quot;)</code></p>
<p>Le second argument (<code class="sourceCode haskell"><span class="st">&quot;r&quot;</span></code>) indique que le fichier doit &#234;tre ouvert en mode <em>read</em>, donc en lecture.</p>
<h3 id="fichiers-textuels-g&#233;n&#233;riques"><a href="#TOC"><span class="header-section-number">7.1.1</span> Fichiers textuels g&#233;n&#233;riques</a></h3>
<p>Une fois le fichier ouvert en lecture, on peut le lire ligne par ligne &#224; l&#8217;aide de la boucle suivante : <code>python fp = open(nom_fichier, &quot;r&quot;, encoding=&quot;utf-8&quot;) for ligne in fp.readlines():     print(ligne)</code> Ici, la variable <code class="sourceCode python">ligne</code>, de type cha&#238;ne de caract&#232;res, contiendra successivement le texte de chacune des lignes du fichier consid&#233;r&#233;.</p>
<h3 id="fichiers-comma-separated-values-csv"><a href="#TOC"><span class="header-section-number">7.1.2</span> Fichiers <em>Comma-Separated Values</em> (CSV)</a></h3>
<p>Les fichiers <em>Comma-Separated Values</em> (CSV) permettent de stocker des donn&#233;es organis&#233;es sous la forme de tableaux dans des fichiers textuels. &#192; l&#8217;origine, ces fichiers &#233;taient organis&#233;es par ligne et au sein de chaque ligne les cellules du tableau (correspondant aux diff&#233;rentes colonnes) &#233;taient s&#233;par&#233;es par des virgules (d&#8217;o&#249; le nom de ce type de fichiers). Aujourd&#8217;hui, la d&#233;finition de ce format (<a href="https://tools.ietf.org/html/rfc4180">lien</a>) est plus g&#233;n&#233;rale que cela et diff&#233;rents d&#233;limiteurs sont accept&#233;s. Pour manipuler ces fichiers, il existe en Python un module d&#233;di&#233;, appel&#233; <code class="sourceCode python">csv</code>. Ce module contient notamment une fonction <code class="sourceCode python">reader</code> permettant de simplifier la lecture de fichiers CSV. La syntaxe d&#8217;utilisation de cette fonction est la suivante (vous remarquerez la pr&#233;sence de l&#8217;attribut <code class="sourceCode python">delimiter</code>) : ```python import csv</p>
<p>nom_fichier = &#8220;&#8230;&#8221; # &#192; remplacer par le chemin vers le fichier :)</p>
<h1 id="contenu-suppos&#233;-du-fichier"><a href="#TOC"><span class="header-section-number">8</span> Contenu suppos&#233; du fichier :</a></h1>
<h1 id="section"><a href="#TOC"><span class="header-section-number">9</span> 1;2;3</a></h1>
<h1 id="ab"><a href="#TOC"><span class="header-section-number">10</span> a;b</a></h1>
<p>fp = open(nom_fichier, &#8220;r&#8221;, encoding=&#8220;utf-8&#8221;) for ligne in csv.reader(fp, delimiter=&#8220;;&#8221;): for cellule in ligne: print(cellule) print(&#8220;Fin de ligne&#8221;) # [Sortie] 1 # [Sortie] 2 # [Sortie] 3 # [Sortie] Fin de ligne # [Sortie] a # [Sortie] b # [Sortie] Fin de ligne ``<code>On remarque ici que, contrairement au cas de fichiers textuels g&#233;n&#233;riques, la variable de boucle</code>ligne`{.python} n&#8217;est plus une cha&#238;ne de caract&#232;res mais une liste de cha&#238;nes de caract&#232;res. Les &#233;l&#233;ments de cette liste sont les cellules du tableau repr&#233;sent&#233; par le fichier CSV.</p>
<h2 id="&#233;criture-de-fichiers-textuels"><a href="#TOC"><span class="header-section-number">10.1</span> &#201;criture de fichiers textuels</a></h2>
<p>Ce que nous apellons &#233;criture de fichiers textuels en Python consiste &#224; copier le contenu d&#8217;une (ou plusieurs) cha&#238;ne(s) de caract&#232;res dans un fichier. Cela implique deux &#233;tapes en Python :</p>
<ol style="list-style-type: decimal">
<li>ouvrir le fichier en &#233;criture ;</li>
<li>ajouter du contenu dans le fichier.</li>
</ol>
<p>La premi&#232;re &#233;tape d&#8217;ouverture du fichier en &#233;criture est commune &#224; tous les types de fichiers textuels. En supposant que le nom du fichier &#224; ouvrir est stock&#233; sous forme de cha&#238;ne de caract&#232;res dans la variable <code class="sourceCode python">nom_fichier</code>, le code suivant ouvre un fichier en &#233;criture avec l&#8217;encodage UTF-8 et stocke dans la variable <code class="sourceCode python">fp</code> un pointeur sur l&#8217;endroit o&#249; nous sommes rendus dans notre &#233;criture du fichier (pour l&#8217;instant, le d&#233;but du fichier) : <code>python fp = open(nom_fichier, &quot;w&quot;, encoding=&quot;utf-8&quot;, newline=&quot;\n&quot;)</code></p>
<p>Le second argument (<code class="sourceCode haskell"><span class="st">&quot;w&quot;</span></code>) indique que le fichier doit &#234;tre ouvert en mode <em>write</em>, donc en &#233;criture.</p>
<p>Si le fichier en question existait d&#233;j&#224;, son contenu est tout d&#8217;abord &#233;cras&#233; et on repart d&#8217;un fichier vide. Si l&#8217;on souhaite au contraire ajouter du texte &#224; la fin d&#8217;un fichier existant, on utilisera le mode <em>append</em>, symbolis&#233; par la lettre <code class="sourceCode haskell"><span class="st">&quot;a&quot;</span></code> : <code>python fp = open(nom_fichier, &quot;a&quot;, encoding=&quot;utf-8&quot;, newline=&quot;\n&quot;)</code></p>
<h3 id="fichiers-textuels-g&#233;n&#233;riques-1"><a href="#TOC"><span class="header-section-number">10.1.1</span> Fichiers textuels g&#233;n&#233;riques</a></h3>
<p>Pour ajouter du contenu &#224; un fichier point&#233; par la variable <code class="sourceCode python">fp</code>, il suffit ensuite d&#8217;utiliser la m&#233;thode <code class="sourceCode python">write</code> : <code>python fp.write(&quot;La vie est belle\n&quot;)</code> Notez que, contrairement &#224; la fonction <code class="sourceCode python"><span class="kw">print</span></code> &#224; laquelle vous &#234;tes habitu&#233;, la m&#233;thode <code class="sourceCode python">write</code> ne rajoute pas de caract&#232;re de fin de ligne apr&#232;s la cha&#238;ne de caract&#232;res pass&#233;e en argument, il faut donc inclure ce caract&#232;re <code class="sourceCode haskell"><span class="st">&quot;\n&quot;</span></code> &#224; la fin de la cha&#238;ne de caract&#232;res pass&#233;e en argument, si vous souhaitez inclure un retour &#224; la ligne.</p>
<h3 id="fichiers-csv"><a href="#TOC"><span class="header-section-number">10.1.2</span> Fichiers CSV</a></h3>
<p>Le module <code class="sourceCode python">csv</code> d&#233;j&#224; cit&#233; plus haut contient &#233;galement une fonction <code class="sourceCode python">writer</code> permettant de simplifier l&#8217;&#233;criture de fichiers CSV. La syntaxe d&#8217;utilisation de cette fonction est la suivante : ```python import csv</p>
<p>nom_fichier = &#8220;&#8230;&#8221; # &#192; remplacer par le chemin vers le fichier :)</p>
<p>fp = open(nom_fichier, &#8220;w&#8221;, encoding=&#8220;utf-8&#8221;, newline=&#8220;&#8221;) csvfp = csv.writer(fp, delimiter=&#8220;;&#8221;): csvfp.writerow([1, 5, 7]) csvfp.writerow([2, 3]) # Apr&#232;s cela, le fichier contiendra les lignes suivantes : # 1;5;7 # 2;3 ``<code>La m&#233;thode</code>writerow<code>{.python} prend donc une liste en argument et &#233;crit dans le fichier les &#233;l&#233;ments de cette liste, s&#233;par&#233;s par le d&#233;limiteur</code>&#8220;;&#8221;<code>{.haskell} sp&#233;cifi&#233; lors de l'appel &#224; la fonction</code>writer<code>{.python}. Le retour &#224; la ligne est &#233;crit directement par la m&#233;thode</code>writerow`{.python}, vous n&#8217;avez pas &#224; vous en occuper.</p>
<h2 id="manipulation-de-fichiers-en-python-avec-le-module-os"><a href="#TOC"><span class="header-section-number">10.2</span> Manipulation de fichiers en Python avec le module <code>os</code></a></h2>
<p>Lorsque l&#8217;on lit ou &#233;crit des fichiers, il est fr&#233;quent de vouloir r&#233;p&#233;ter la m&#234;me op&#233;ration sur plusieurs fichiers, par exemple sur tous les fichiers avec l&#8217;extension <code class="sourceCode haskell"><span class="st">&quot;.txt&quot;</span></code> d&#8217;un r&#233;pertoire donn&#233;. Pour ce faire, on peut utiliser en Python le module <code class="sourceCode python">os</code> qui propose un certain nombre de fonctions standard de manipulation de fichiers. On utilisera notamment la fonction <code class="sourceCode python">listdir</code> de ce module qui permet de lister l&#8217;ensemble des fichiers et sous-r&#233;pertoires contenus dans un r&#233;pertoire donn&#233; : ```python import os</p>
<p>for nom_fichier in os.listdir(&#8220;donnees&#8221;): print(nom_fichier) ```</p>
<p>La fonction <code class="sourceCode python">listdir</code> peut prendre indiff&#233;remment un chemin absolu ou relatif (dans notre exemple, il s&#8217;agit d&#8217;un chemin relatif qui pointe sur le sous-r&#233;pertoire <code class="sourceCode haskell"><span class="st">&quot;donnees&quot;</span></code> contenu dans le r&#233;pertoire de travail courant du programme).</p>
<p>Si vous ex&#233;cutez le code ci-dessus et que votre r&#233;pertoire <code class="sourceCode haskell"><span class="st">&quot;donnees&quot;</span></code> n&#8217;est pas vide, vous remarquerez que le nom du fichier stock&#233; dans la variable <code class="sourceCode python">nom_fichier</code> ne contient pas le chemin vers ce fichier. Or, si l&#8217;on souhaite ensuite ouvrir ce fichier (que ce soit en lecture ou en &#233;criture), il faudra bien sp&#233;cifier ce chemin. Pour cela, on utilisera la syntaxe suivante : ```python import os</p>
<p>repertoire = &#8220;donnees&#8221; for nom_fichier in os.listdir(repertoire): nom_complet_fichier = os.path.join(repertoire, nom_fichier) print(nom_fichier) print(nom_complet_fichier) fp = open(nom_complet_fichier, &#8220;r&#8221;, encoding=&#8220;utf-8&#8221;) # [&#8230;] ``<code>La fonction</code>path.join<code>{.python} du module</code>os<code>{.python} permet d'obtenir le chemin complet vers le fichier &#224; partir du nom du r&#233;pertoire dans lequel il se trouve et du nom du fichier isol&#233;. Il est pr&#233;f&#233;rable d'utiliser cette fonction plut&#244;t que d'effectuer la concat&#233;nation des cha&#238;nes de caract&#232;res correspondantes car la forme des chemins complets d&#233;pend du syst&#232;me d'exploitation utilis&#233;, ce que g&#232;re intelligemment</code>path.join`{.python}.</p>
<p><strong>Exercice 6.1</strong> &#201;crivez une fonction qui affiche, pour chaque fichier d&#8217;extension <code class="sourceCode haskell"><span class="st">&quot;.txt&quot;</span></code> d&#8217;un r&#233;pertoire pass&#233; en argument, le nom du fichier ainsi que son nombre de lignes.</p>
<p><strong>Exercice 6.2</strong> &#201;crivez une fonction qui retourne le nombre de fichiers pr&#233;sents dans un r&#233;pertoire dont le nom est pass&#233; en argument. Vous pourrez vous aider pour cela de la documentation du sous-module <code class="sourceCode python">path</code> du module <code class="sourceCode python">os</code> (<a href="https://docs.python.org/3.5/library/os.path.html">lien</a>).</p>
<h1 id="tester-son-code"><a href="#TOC"><span class="header-section-number">11</span> Tester son code</a></h1>
<p>Dans ce document, nous avons jusqu&#8217;&#224; pr&#233;sent suppos&#233; que tout se passait bien, que votre code ne retournait jamais d&#8217;erreur et qu&#8217;il ne contenait jamais de <em>bug</em>. Quel que soit votre niveau d&#8217;expertise en Python, ces deux hypoth&#232;ses sont peu r&#233;alistes. Nous allons donc nous int&#233;resser maintenant aux moyens de v&#233;rifier si votre code fait bien ce qu&#8217;on attend de lui et de mieux comprendre son comportement lorsque ce n&#8217;est pas le cas.</p>
<h2 id="les-erreurs-en-python"><a href="#TOC"><span class="header-section-number">11.1</span> Les erreurs en Python</a></h2>
<p>&#201;tudions ce qu&#8217;il se passe lors de l&#8217;ex&#233;cution du code suivant : <code>{.python .numberLines} x = &quot;12&quot; y = x + 2</code></p>
<p>Nous obtenons la sortie suivante : <code>{.python-traceback} Traceback (most recent call last):   File &quot;[...]&quot;, line 2, in &lt;module&gt;     y = x + 2 TypeError: Can't convert 'int' object to str implicitly</code></p>
<p>Ce type de message d&#8217;erreur ne doit pas vous effrayer, il est l&#224; pour vous aider. Il vous fournit de pr&#233;cieuses informations :</p>
<ol style="list-style-type: decimal">
<li>l&#8217;erreur se produit &#224; la ligne 2 de votre script Python ;</li>
<li>le probl&#232;me est que Python ne peut pas convertir un objet de type <code class="sourceCode python"><span class="dt">int</span></code> en cha&#238;ne de caract&#232;res (<code class="sourceCode python"><span class="dt">str</span></code>) de mani&#232;re implicite.</li>
</ol>
<p>Reste &#224; se demander pourquoi, dans le cas pr&#233;sent, Python voudrait transformer un entier en cha&#238;ne de caract&#232;res. Pour le comprendre, rendons-nous &#224; la ligne 2 de notre script et d&#233;cortiquons-la. Dans cette ligne (<code class="sourceCode python">y = x + <span class="dv">2</span></code>), deux op&#233;rations sont effectu&#233;es :</p>
<ul>
<li>la premi&#232;re consiste &#224; effectuer l&#8217;op&#233;ration <code class="sourceCode python">+</code> entre les op&#233;randes <code class="sourceCode python">x</code> et <code>2</code> ;</li>
<li>la seconde consiste &#224; assigner le r&#233;sultat de l&#8217;op&#233;ration &#224; la variable <code class="sourceCode python">y</code>.</li>
</ul>
<p>Nous avons vu dans ce document que Python savait effectuer l&#8217;op&#233;ration <code class="sourceCode python">+</code> avec des op&#233;randes de types vari&#233;s (nombre <code class="sourceCode python">+</code> nombre, liste <code class="sourceCode python">+</code> liste, cha&#238;ne de caract&#232;res <code class="sourceCode python">+</code> cha&#238;ne de caract&#232;res, et il en existe d&#8217;autres). Int&#233;ressons-nous ici au type des op&#233;randes consid&#233;r&#233;es. La variable <code class="sourceCode python">x</code> telle que d&#233;finie &#224; la ligne 1 est de type cha&#238;ne de caract&#232;res. La valeur <code class="sourceCode python"><span class="dv">2</span></code> est de type entier. Il se trouve que Python n&#8217;a pas d&#233;fini d&#8217;addition entre cha&#238;ne de caract&#232;res et entier et c&#8217;est pour cela que l&#8217;on obtient une erreur. Plus pr&#233;cis&#233;ment, l&#8217;interpr&#233;teur Python nous dit : &#8220;si je pouvais convertir la valeur enti&#232;re en cha&#238;ne de caract&#232;res &#224; la vol&#233;e, je pourrais faire l&#8217;op&#233;ration <code class="sourceCode python">+</code> qui serait alors une concat&#233;nation, mais je ne me permets pas de le faire tant que vous ne l&#8217;avez pas &#233;crit de mani&#232;re explicite&#8221;.</p>
<p>Maintenant que nous avons compris le sens de ce <em>bug</em>, il nous reste &#224; le corriger. Si nous souhaitons faire la somme du nombre 10 (stock&#233; sous forme de cha&#238;ne de caract&#232;res dans la variable <code class="sourceCode python">x</code>) et de la valeur 2, nous &#233;crivons : <code>python x = &quot;12&quot; y = int(x) + 2</code> et l&#8217;addition s&#8217;effectue alors correctement entre deux valeurs num&#233;riques.</p>
<h2 id="les-tests-unitaires"><a href="#TOC"><span class="header-section-number">11.2</span> Les tests unitaires</a></h2>
<p>Pour pouvoir &#234;tre s&#251;r du code que vous &#233;crivez, il faut l&#8217;avoir test&#233; sur un ensemble d&#8217;exemples qui vous semble refl&#233;ter l&#8217;ensemble des cas de figures auxquels votre programme pourra &#234;tre confront&#233;. Or, cela repr&#233;sente un nombre de cas de figures tr&#232;s important d&#232;s lors que l&#8217;on commence &#224; &#233;crire des programmes un tant soit peu complexes. Ainsi, il est hautement recommand&#233; de d&#233;couper son code en fonctions de tailles raisonnables et qui puissent &#234;tre test&#233;es ind&#233;pendamment. Les tests associ&#233;s &#224; chacune de ces fonctions sont appel&#233;s <strong>tests unitaires</strong>.</p>
<p>Tout d&#8217;abord, en mettant en place de tels tests, vous pourrez d&#233;tecter rapidement un &#233;ventuel <em>bug</em> dans votre code et ainsi gagner beaucoup de temps de d&#233;veloppement. De plus, vous pourrez &#233;galement vous assurer que les modifications ult&#233;rieures de votre code ne modifient pas son comportement pour les cas test&#233;s. En effet, lorsque l&#8217;on ajoute une fonctionnalit&#233; &#224; un programme informatique, il faut avant toute choses s&#8217;assurer que celle-ci ne cassera pas le bon fonctionnement du programme dans les cas classiques d&#8217;utilisation pour lesquels il avait &#233;t&#233; &#224; l&#8217;origine con&#231;u.</p>
<p>Prenons maintenant un exemple concret. Supposons que l&#8217;on souhaite &#233;crire une fonction <code class="sourceCode python">bissextile</code> capable de dire si une ann&#233;e est bissextile ou non. En se renseignant sur <a href="https://fr.wikipedia.org/wiki/Ann&#233;e_bissextile">le sujet</a>, on apprend qu&#8217;une ann&#233;e est bissextile si :</p>
<ul>
<li>si elle est divisible par 4 et non divisible par 100, ou</li>
<li>si elle est divisible par 400.</li>
</ul>
<p>On en d&#233;duit un ensemble de tests adapt&#233;s : <code>python print(bissextile(2004))  # True car divisible par 4 et non par 100 print(bissextile(1900))  # False car divisible par 100 et non par 400 print(bissextile(2000))  # True car divisible par 400 print(bissextile(1999))  # False car divisible ni par 4 ni par 100</code></p>
<p>On peut alors v&#233;rifier que le comportement de notre fonction <code class="sourceCode python">bissextile</code> est bien conforme &#224; ce qui est attendu.</p>
<h2 id="le-d&#233;veloppement-pilot&#233;-par-les-tests"><a href="#TOC"><span class="header-section-number">11.3</span> Le d&#233;veloppement pilot&#233; par les tests</a></h2>
<p>Le d&#233;veloppement pilot&#233; par les tests (ou <em>Test-Driven Development</em>) est une technique de programmation qui consiste &#224; r&#233;diger les tests unitaires de votre programme avant m&#234;me de r&#233;diger le programme lui-m&#234;me.</p>
<p>L&#8217;int&#233;r&#234;t de cette fa&#231;on de faire est qu&#8217;elle vous obligera &#224; r&#233;fl&#233;chir aux diff&#233;rents cas d&#8217;utilisation d&#8217;une fonction avant de commencer &#224; la coder. De plus, une fois ces diff&#233;rents cas identifi&#233;s, il est probable que la structure globale de la fonction &#224; coder vous apparaisse plus clairement.</p>
<p>Si l&#8217;on reprend l&#8217;exemple de la fonction <code class="sourceCode python">bissextile</code> cit&#233;e plus haut, on voit assez clairement qu&#8217;une fois que l&#8217;on a r&#233;dig&#233; l&#8217;ensemble de tests, la fonction sera simple &#224; coder et reprendra les diff&#233;rents cas consid&#233;r&#233;s pour les tests: <code>python def bissextile(annee):     if annee % 4 == 0 and annee % 100 != 0:         return True     elif annee % 400 == 0:         return True     else:         return False</code></p>
<p><strong>Exercice 7.1</strong> En utilisant les m&#233;thodes de d&#233;veloppement pr&#233;conis&#233;es dans ce chapitre, r&#233;digez le code et les tests d&#8217;un programme permettant de d&#233;terminer le lendemain d&#8217;une date fournie sous la forme de trois entiers (jour, mois, ann&#233;e).</p>
<h1 id="conclusion"><a href="#TOC"><span class="header-section-number">12</span> Conclusion</a></h1>
<p>Dans ce document, nous avons abord&#233; les principes de base de la programmation en Python, tels qu&#8217;enseign&#233;s &#224; des &#233;tudiants non informaticiens de niveau Licence 2 (&#224; l&#8217;Universit&#233; de Rennes 2).</p>
<p>Comme indiqu&#233; en introduction, ce document se veut &#233;volutif. N&#8217;h&#233;sitez donc pas &#224; faire vos remarques &#224; son auteur dont vous trouverez le contact sur <a href="http://people.irisa.fr/Romain.Tavenard/">sa page web</a>.</p>
</body>
</html>
